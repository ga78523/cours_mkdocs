{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs # For full documentation visit mkdocs.org . Commands # mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout # mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. about.md # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. about.md # Other markdown pages, images and other files.","title":"Project layout"},{"location":"about/","text":"https://www.sujetdebac.fr/annales/specialites/spe-numerique-informatique/2021/ https://isn-icn-ljm.pagesperso-orange.fr/NSI-TLE/index.html https://lesmathsduyeti.fr/fr/lycee/nsi-terminale/ https://www.waterman.fr/ http://tnsi.free.fr/ https://www.lumni.fr/lycee/terminale/specialites/numerique-et-sciences-informatiques-1 https://www.lyceerotroudreux.com/index.php?option=com_content&view=article&id=362&Itemid=261&lang=fr https://www.lecluse.fr/ https://www.lyceum.fr/ https://pixees.fr/informatiquelycee/term/c12a.html https://www.math93.com/lycee/nsi-1ere.html http://www.monlyceenumerique.fr/index_maths.html https://nsi4noobs.fr/-Actualites- https://nsi.spip.ac-rouen.fr/spip.php?article26 https://pixees.fr/informatiquelycee/n_site/nsi_term.html https://frederic-junier.gitlab.io/parc-nsi/ https://realpython.com/ https://qkzk.xyz/docs/nsi/cours_terminale/ https://kxs.fr/cours/poo/poo-hors-programme https://lewebpedagogique.com/dlaporte/corrections-epreuves-pratiques-2021-nsi/ https://www.sujetdebac.fr/annales/spe-numerique-informatique-2021-metro-cand-libre-1","title":"About"},{"location":"Physique/Seconde/mesure_c_son/","text":"Mesure de la vitesse du son # Contexte # Le son peut \u00eatre d\u00e9fini comme la vibration m\u00e9canique d\u2019un fluide, qui se propage sous forme d\u2019ondes [...] gr\u00e2ce \u00e0 la d\u00e9formation \u00e9lastique de ce fluide (Wikip\u00e9dia). En r\u00e9sum\u00e9, tout comme l\u2019onde qui se propage au fil de l\u2019eau lorsque vous y jetez un caillou, l\u2019onde sonore, ou accoustique, se d\u00e9place dans l\u2019air (ou tout autre fluide, liquide ou gazeux) sous forme de compressions r\u00e9guli\u00e8res de ce fluide (voir illustration ci-dessous). Plus les compressions se succ\u00e8dent rapidement, plus la fr\u00e9quence du son est \u00e9lev\u00e9e, donc le son per\u00e7u aigu. Plus elles sont lentes, plus la fr\u00e9quence est basse et le son grave. L'onde sonore a une vitesse propre, qui d\u00e9pend de la densit\u00e9 du fluide dans lequel elle se d\u00e9place et sa temp\u00e9rature (2 param\u00e8tres qui influent sur la pression du fluide). L'objectif de cette activit\u00e9 est d'appliquer une d\u00e9marche scientifique afin de mesurer exp\u00e9rimentalement la vitesse du son dans l'air \u00e0 temp\u00e9rature ambiante. Objectif # L'objectif de cette activit\u00e9 est de v\u00e9rifier la vitesse du son dans l'air en mesurant de fa\u00e7on pr\u00e9cise, avec Arduino, les temps de r\u00e9ception d'un \u00e9cho d'ultrason se r\u00e9percutant sur un obstacle situ\u00e9 \u00e0 diff\u00e9rentes distances. Principe du capteur \u00e0 ultra-son # Le capteur de distance fonctionne sur le principe de l'\u00e9cholocalisation : il est \u00e9quip\u00e9 d'un \u00e9metteur et un r\u00e9cepteur ultrason, ce qui lui permet de d\u00e9tecter des obstacles distants \u00e0 la mani\u00e8re des chauves-souris ou des c\u00e9tac\u00e9s. Il peut \u00eatre programm\u00e9 pour \u00e9mettre un court ultrason et calculer le temps de r\u00e9ception de son \u00e9cho, qui est fonction de la distance de l'obstacle et de la vitesse du son. Exp\u00e9rience # Montage # Vous remarquerez que le c\u00e2blage est on ne peut plus simple : un Arduino et un capteur de distance ! Les pins \"vcc\" et \"GND\" du capteur de distance seront branch\u00e9es sur 5V et ground respectivement. La pin \"Trig\" (\u00e9metteur) sera branch\u00e9 sur la prise 13 de l'Arduino, et la pin \"Echo\" (r\u00e9cepteur) sur la prise 12 de l'Arduino.. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //Calcul de la vitesse du son avec Arduino //Affichage du temps de reception d'un \u00e9cho int emetteur = 13 ; //branch\u00e9 sur trig du HC-SR04 int recepteur = 12 ; //branch\u00e9 sur echo du HC-SR04 long Delta_t ; //variable type long void setup () { Serial . begin ( 9600 ); pinMode ( emetteur , OUTPUT ); pinMode ( recepteur , INPUT ); } void loop () { //\u00c9mission d'un pulse ultrason sur la pin 13: emetteur allum\u00e9 pour 10 microsecondes digitalWrite ( emetteur , HIGH ); delayMicroseconds ( 10 ); // Added this line digitalWrite ( emetteur , LOW ); //Mesure du temps entre l'\u00e9mission et la r\u00e9ception Delta_t = pulseIn ( recepteur , HIGH ); //en microsecond //Affichage du temps, rafraichi toutes les 200ms Serial . println ( Delta_t ); delay ( 1000 ); } Explications du code # Dans un premier temps nous d\u00e9clarons les variables. Les variables \"emetteur\" et \"recepteur\" dans lesquelles seront d\u00e9clar\u00e9s les num\u00e9ros de pin utilis\u00e9es respectivement par \"Trig\" et \"Echo\" du capteur HC-SR04. La variable \"Delta_t\" de type long (entier et grande pr\u00e9cision) dans laquelle sera stock\u00e9 le temps \u00e9coul\u00e9 entre deux r\u00e9ceptions de l'\u00e9cho. Puis vient la partie d'initialisation : le void setup. Tr\u00e8s simple, il ne comporte que trois lignes : Initialisation de la communication s\u00e9rie qui nous permettra de lire la valeur de \"Delta_t\", c'est \u00e0 dire le temps mis par l'\u00e9cho pour parvenir au r\u00e9cepteur. Initialisation de la pin \"emetteur\" (pin 13) en sortie (afin de produire un signal sonore). Initialisation de la pin \"recepteur\" (pin 12) en entr\u00e9e (afin de recevoir un signal sonore). Et pour finir, la boucle principale : le void loop. Les trois premi\u00e8res lignes permettent d'\u00e9mettre un pulse ultrason : La pin \"emetteur\" est mis \u00e0 l'\u00e9tat HIGH : l'\u00e9metteur du capteur produit un ultrason. Pause de 20 microsecondes La pin \"emetteur\" est mis \u00e0 l'\u00e9tat LOW : l'\u00e9metteur du capteur ne produit plus d'ultrason. En r\u00e9sum\u00e9, nous venons d'\u00e9mettre une onde sonore \u00e0 tr\u00e8s haute fr\u00e9quence (domaine des ultrasons) durant 20 microsecondes. * La variable \"Delta_t\" prend la valeur de \"pulseIn (emetteur, HIGH)\". La fonction pulseIn permet de mesurer une dur\u00e9e d'impulsion. En r\u00e9sum\u00e9, la pin nomm\u00e9e \"recepteur\" va se mettre \u00e0 l'\u00e9coute d'un signal (\u00e9tat HIGH). Lorsqu'elle aura atteint l'\u00e9tat demand\u00e9 (HIGH), le programme va compter le temps \u00e9coul\u00e9 (en microsecondes) jusqu'\u00e0 ce que la pin perde son \u00e9tat (donc retourne \u00e0 LOW). Pour plus de d\u00e9tails, consultez ceci. La variable \"Delta\\t\" correspond donc au temps \u00e9coul\u00e9 entre 2 \u00e9tats HIGH de la pin \"recepteur\", soit 2 r\u00e9ceptions de signal. Ce qui correspond \u00e0 un aller-retour de l'onde sonore entre l'\u00e9metteur et l'obstacle. Affichage du \"pulseIn\" dans le moniteur s\u00e9rie. D\u00e9lai d'une seconde (1000ms) entre 2 affichages de mesure. Assemblage # Vous pouvez maintenant brancher votre arduino et t\u00e9l\u00e9verser le programme. Cliquez sur la loupe en haut \u00e0 droite de la fen\u00eatre Arduino pour faire appara\u00eetre le moniteur s\u00e9rie. Par d\u00e9faut il sera r\u00e9gl\u00e9 sur le d\u00e9bit de 9600 bauds. Vous verrez alors dans la nouvelle fen\u00eatre une succession de nombre : c'est le temps de r\u00e9ception de l'\u00e9cho, en microsecondes, rafra\u00eechi toutes les secondes (la variable \"Delta_t\") Mise en place de l'exp\u00e9rience # Nous allons mesurer le temps de parcours de l'\u00e9cho pour plusieurs distances. Il faudra donc positionner un obstacle face au capteur de distance. J'ai choisi les distances capteur-obstacle suivantes : * 20 cm ; * 40 cm ; * 60 cm. \u00c9tant donn\u00e9 que nous mesurons le temps mis par l'\u00e9cho pour parvenir au r\u00e9cepteur, la distance parcourue par l'onde sonore sera le double (un aller-retour), soit : 40 cm ; 80 cm ; 120 cm. Positionnez l'obstacle \u00e0 la distance souhait\u00e9e puis d\u00e9marrez l'exp\u00e9rience en ouvrant la fen\u00eatre du moniteur s\u00e9rie (pour rappel, il s'agit d'appuyer sur la loupe en haut \u00e0 droite de la fen\u00eatre Arduino). Vous verrez s'afficher dans cette fen\u00eatre le temps, en microsecondes, mis par l'onde sonore pour faire un aller-retour entre le capteur et l'obstacle. Les donn\u00e9es devraient \u00eatre relativement stables, particuli\u00e8rement pour les plus courtes distances. Notez 5 valeurs parmi les donn\u00e9es recueillies, dans chaque condition. Voici un exemple : Ici sont s\u00e9lectionn\u00e9s les valeurs maximales et minimales ainsi que celles qui semblent le plus repr\u00e9sentatives. R\u00e9sultats # Nous allons mesurer du temps de parcours de diff\u00e9rentes distances par l'onde sonore. Distance (cm) temp1s temps2 temps3 temps4 temps5 temps moyen ( \\(\\mu\\) s) Le tableau suivant r\u00e9sume les r\u00e9sultats pr\u00e9c\u00e9dents, c'est \u00e0 dire les distances et les temps de parcours moyens obtenus dans mes conditions : Distance (cm) 20 cm 40cm 60 cm Distance parcourue par l'onde (cm) temps moyen ( \\(\\mu\\) s) Exploitation et conclusion # D\u00e9terminer la vitesse du son pour ces trois distances ; En faire la moyenne. Conclure Pour les plus rapides # Exercice # Le sonar est un capteur form\u00e9 d'une sonde qui contient un \u00e9metteur \\(E\\) et un r\u00e9cepteur \\(R\\) des ultrasons. Il est utilis\u00e9 dans la navigation maritime pour conna\u00eetre la profondeur d'eau et permet aux navires de s'approcher de la cote en toute confiance. Pour d\u00e9terminer la profondeur, l'\u00e9metteur \\(E\\) \u00e9met des ultrasons sinuso\u00efdales vers le fond de la mer, une partie de ces ultrasons r\u00e9fl\u00e9chissent et sont capt\u00e9es par le r\u00e9cepteur \\(R\\) . Le graphe ci-dessous repr\u00e9sente le signal \u00e9mis par E et le signal re\u00e7u par R. Quelle est la diff\u00e9rence entre les ondes sonores et les ondes ultrasonores ? Rappeler l'expression (la formule ) de la vitesse (autrement appel\u00e9e c\u00e9l\u00e9rit\u00e9) d'une onde. Vous exprimerez cette vitesse en fonction de la distance \\(d\\) (m) et en fonction de la dur\u00e9e de l'aller-retour \\(\\Delta t\\) (s). On utilise des ultrasons de fr\u00e9quence \\(f\\) = 200 kHz qui se propagent dans l'eau de mer avec une c\u00e9l\u00e9rit\u00e9 \\(v_{eau} = 1500\\) m.s \\(^{-1}\\) a. \u00c0 partir du graphe, d\u00e9terminer la dur\u00e9e \\(\\Delta t\\) entre l'\u00e9mission 1 et la r\u00e9ception 2. b. On suppose que les ultrasons suivent une trajectoire verticale. Calculer la valeur de \\(d\\) . Capteur de distance # R\u00e9aliser un capteur de distance. Ce capteur donnera une distance en cm. Pour cela, il faut : d\u00e9clarer une autre variable \\(d\\) de type double ; trouver l'expression de la distance \\(d\\) en fonction des autres variables du programme ; Attention aux unit\u00e9s l'afficher \u00e0 l'aide de la fonction Serial.println() .","title":"Mesure de la c\u00e9l\u00e9rit\u00e9 du son"},{"location":"Physique/Seconde/mesure_c_son/#mesure-de-la-vitesse-du-son","text":"","title":"Mesure de la vitesse du son"},{"location":"Physique/Seconde/mesure_c_son/#contexte","text":"Le son peut \u00eatre d\u00e9fini comme la vibration m\u00e9canique d\u2019un fluide, qui se propage sous forme d\u2019ondes [...] gr\u00e2ce \u00e0 la d\u00e9formation \u00e9lastique de ce fluide (Wikip\u00e9dia). En r\u00e9sum\u00e9, tout comme l\u2019onde qui se propage au fil de l\u2019eau lorsque vous y jetez un caillou, l\u2019onde sonore, ou accoustique, se d\u00e9place dans l\u2019air (ou tout autre fluide, liquide ou gazeux) sous forme de compressions r\u00e9guli\u00e8res de ce fluide (voir illustration ci-dessous). Plus les compressions se succ\u00e8dent rapidement, plus la fr\u00e9quence du son est \u00e9lev\u00e9e, donc le son per\u00e7u aigu. Plus elles sont lentes, plus la fr\u00e9quence est basse et le son grave. L'onde sonore a une vitesse propre, qui d\u00e9pend de la densit\u00e9 du fluide dans lequel elle se d\u00e9place et sa temp\u00e9rature (2 param\u00e8tres qui influent sur la pression du fluide). L'objectif de cette activit\u00e9 est d'appliquer une d\u00e9marche scientifique afin de mesurer exp\u00e9rimentalement la vitesse du son dans l'air \u00e0 temp\u00e9rature ambiante.","title":"Contexte"},{"location":"Physique/Seconde/mesure_c_son/#objectif","text":"L'objectif de cette activit\u00e9 est de v\u00e9rifier la vitesse du son dans l'air en mesurant de fa\u00e7on pr\u00e9cise, avec Arduino, les temps de r\u00e9ception d'un \u00e9cho d'ultrason se r\u00e9percutant sur un obstacle situ\u00e9 \u00e0 diff\u00e9rentes distances.","title":"Objectif"},{"location":"Physique/Seconde/mesure_c_son/#principe-du-capteur-a-ultra-son","text":"Le capteur de distance fonctionne sur le principe de l'\u00e9cholocalisation : il est \u00e9quip\u00e9 d'un \u00e9metteur et un r\u00e9cepteur ultrason, ce qui lui permet de d\u00e9tecter des obstacles distants \u00e0 la mani\u00e8re des chauves-souris ou des c\u00e9tac\u00e9s. Il peut \u00eatre programm\u00e9 pour \u00e9mettre un court ultrason et calculer le temps de r\u00e9ception de son \u00e9cho, qui est fonction de la distance de l'obstacle et de la vitesse du son.","title":"Principe du capteur \u00e0 ultra-son"},{"location":"Physique/Seconde/mesure_c_son/#experience","text":"","title":"Exp\u00e9rience"},{"location":"Physique/Seconde/mesure_c_son/#montage","text":"Vous remarquerez que le c\u00e2blage est on ne peut plus simple : un Arduino et un capteur de distance ! Les pins \"vcc\" et \"GND\" du capteur de distance seront branch\u00e9es sur 5V et ground respectivement. La pin \"Trig\" (\u00e9metteur) sera branch\u00e9 sur la prise 13 de l'Arduino, et la pin \"Echo\" (r\u00e9cepteur) sur la prise 12 de l'Arduino.. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //Calcul de la vitesse du son avec Arduino //Affichage du temps de reception d'un \u00e9cho int emetteur = 13 ; //branch\u00e9 sur trig du HC-SR04 int recepteur = 12 ; //branch\u00e9 sur echo du HC-SR04 long Delta_t ; //variable type long void setup () { Serial . begin ( 9600 ); pinMode ( emetteur , OUTPUT ); pinMode ( recepteur , INPUT ); } void loop () { //\u00c9mission d'un pulse ultrason sur la pin 13: emetteur allum\u00e9 pour 10 microsecondes digitalWrite ( emetteur , HIGH ); delayMicroseconds ( 10 ); // Added this line digitalWrite ( emetteur , LOW ); //Mesure du temps entre l'\u00e9mission et la r\u00e9ception Delta_t = pulseIn ( recepteur , HIGH ); //en microsecond //Affichage du temps, rafraichi toutes les 200ms Serial . println ( Delta_t ); delay ( 1000 ); }","title":"Montage"},{"location":"Physique/Seconde/mesure_c_son/#explications-du-code","text":"Dans un premier temps nous d\u00e9clarons les variables. Les variables \"emetteur\" et \"recepteur\" dans lesquelles seront d\u00e9clar\u00e9s les num\u00e9ros de pin utilis\u00e9es respectivement par \"Trig\" et \"Echo\" du capteur HC-SR04. La variable \"Delta_t\" de type long (entier et grande pr\u00e9cision) dans laquelle sera stock\u00e9 le temps \u00e9coul\u00e9 entre deux r\u00e9ceptions de l'\u00e9cho. Puis vient la partie d'initialisation : le void setup. Tr\u00e8s simple, il ne comporte que trois lignes : Initialisation de la communication s\u00e9rie qui nous permettra de lire la valeur de \"Delta_t\", c'est \u00e0 dire le temps mis par l'\u00e9cho pour parvenir au r\u00e9cepteur. Initialisation de la pin \"emetteur\" (pin 13) en sortie (afin de produire un signal sonore). Initialisation de la pin \"recepteur\" (pin 12) en entr\u00e9e (afin de recevoir un signal sonore). Et pour finir, la boucle principale : le void loop. Les trois premi\u00e8res lignes permettent d'\u00e9mettre un pulse ultrason : La pin \"emetteur\" est mis \u00e0 l'\u00e9tat HIGH : l'\u00e9metteur du capteur produit un ultrason. Pause de 20 microsecondes La pin \"emetteur\" est mis \u00e0 l'\u00e9tat LOW : l'\u00e9metteur du capteur ne produit plus d'ultrason. En r\u00e9sum\u00e9, nous venons d'\u00e9mettre une onde sonore \u00e0 tr\u00e8s haute fr\u00e9quence (domaine des ultrasons) durant 20 microsecondes. * La variable \"Delta_t\" prend la valeur de \"pulseIn (emetteur, HIGH)\". La fonction pulseIn permet de mesurer une dur\u00e9e d'impulsion. En r\u00e9sum\u00e9, la pin nomm\u00e9e \"recepteur\" va se mettre \u00e0 l'\u00e9coute d'un signal (\u00e9tat HIGH). Lorsqu'elle aura atteint l'\u00e9tat demand\u00e9 (HIGH), le programme va compter le temps \u00e9coul\u00e9 (en microsecondes) jusqu'\u00e0 ce que la pin perde son \u00e9tat (donc retourne \u00e0 LOW). Pour plus de d\u00e9tails, consultez ceci. La variable \"Delta\\t\" correspond donc au temps \u00e9coul\u00e9 entre 2 \u00e9tats HIGH de la pin \"recepteur\", soit 2 r\u00e9ceptions de signal. Ce qui correspond \u00e0 un aller-retour de l'onde sonore entre l'\u00e9metteur et l'obstacle. Affichage du \"pulseIn\" dans le moniteur s\u00e9rie. D\u00e9lai d'une seconde (1000ms) entre 2 affichages de mesure.","title":"Explications du code"},{"location":"Physique/Seconde/mesure_c_son/#assemblage","text":"Vous pouvez maintenant brancher votre arduino et t\u00e9l\u00e9verser le programme. Cliquez sur la loupe en haut \u00e0 droite de la fen\u00eatre Arduino pour faire appara\u00eetre le moniteur s\u00e9rie. Par d\u00e9faut il sera r\u00e9gl\u00e9 sur le d\u00e9bit de 9600 bauds. Vous verrez alors dans la nouvelle fen\u00eatre une succession de nombre : c'est le temps de r\u00e9ception de l'\u00e9cho, en microsecondes, rafra\u00eechi toutes les secondes (la variable \"Delta_t\")","title":"Assemblage"},{"location":"Physique/Seconde/mesure_c_son/#mise-en-place-de-lexperience","text":"Nous allons mesurer le temps de parcours de l'\u00e9cho pour plusieurs distances. Il faudra donc positionner un obstacle face au capteur de distance. J'ai choisi les distances capteur-obstacle suivantes : * 20 cm ; * 40 cm ; * 60 cm. \u00c9tant donn\u00e9 que nous mesurons le temps mis par l'\u00e9cho pour parvenir au r\u00e9cepteur, la distance parcourue par l'onde sonore sera le double (un aller-retour), soit : 40 cm ; 80 cm ; 120 cm. Positionnez l'obstacle \u00e0 la distance souhait\u00e9e puis d\u00e9marrez l'exp\u00e9rience en ouvrant la fen\u00eatre du moniteur s\u00e9rie (pour rappel, il s'agit d'appuyer sur la loupe en haut \u00e0 droite de la fen\u00eatre Arduino). Vous verrez s'afficher dans cette fen\u00eatre le temps, en microsecondes, mis par l'onde sonore pour faire un aller-retour entre le capteur et l'obstacle. Les donn\u00e9es devraient \u00eatre relativement stables, particuli\u00e8rement pour les plus courtes distances. Notez 5 valeurs parmi les donn\u00e9es recueillies, dans chaque condition. Voici un exemple : Ici sont s\u00e9lectionn\u00e9s les valeurs maximales et minimales ainsi que celles qui semblent le plus repr\u00e9sentatives.","title":"Mise en place de l'exp\u00e9rience"},{"location":"Physique/Seconde/mesure_c_son/#resultats","text":"Nous allons mesurer du temps de parcours de diff\u00e9rentes distances par l'onde sonore. Distance (cm) temp1s temps2 temps3 temps4 temps5 temps moyen ( \\(\\mu\\) s) Le tableau suivant r\u00e9sume les r\u00e9sultats pr\u00e9c\u00e9dents, c'est \u00e0 dire les distances et les temps de parcours moyens obtenus dans mes conditions : Distance (cm) 20 cm 40cm 60 cm Distance parcourue par l'onde (cm) temps moyen ( \\(\\mu\\) s)","title":"R\u00e9sultats"},{"location":"Physique/Seconde/mesure_c_son/#exploitation-et-conclusion","text":"D\u00e9terminer la vitesse du son pour ces trois distances ; En faire la moyenne. Conclure","title":"Exploitation et conclusion"},{"location":"Physique/Seconde/mesure_c_son/#pour-les-plus-rapides","text":"","title":"Pour les plus rapides"},{"location":"Physique/Seconde/mesure_c_son/#exercice","text":"Le sonar est un capteur form\u00e9 d'une sonde qui contient un \u00e9metteur \\(E\\) et un r\u00e9cepteur \\(R\\) des ultrasons. Il est utilis\u00e9 dans la navigation maritime pour conna\u00eetre la profondeur d'eau et permet aux navires de s'approcher de la cote en toute confiance. Pour d\u00e9terminer la profondeur, l'\u00e9metteur \\(E\\) \u00e9met des ultrasons sinuso\u00efdales vers le fond de la mer, une partie de ces ultrasons r\u00e9fl\u00e9chissent et sont capt\u00e9es par le r\u00e9cepteur \\(R\\) . Le graphe ci-dessous repr\u00e9sente le signal \u00e9mis par E et le signal re\u00e7u par R. Quelle est la diff\u00e9rence entre les ondes sonores et les ondes ultrasonores ? Rappeler l'expression (la formule ) de la vitesse (autrement appel\u00e9e c\u00e9l\u00e9rit\u00e9) d'une onde. Vous exprimerez cette vitesse en fonction de la distance \\(d\\) (m) et en fonction de la dur\u00e9e de l'aller-retour \\(\\Delta t\\) (s). On utilise des ultrasons de fr\u00e9quence \\(f\\) = 200 kHz qui se propagent dans l'eau de mer avec une c\u00e9l\u00e9rit\u00e9 \\(v_{eau} = 1500\\) m.s \\(^{-1}\\) a. \u00c0 partir du graphe, d\u00e9terminer la dur\u00e9e \\(\\Delta t\\) entre l'\u00e9mission 1 et la r\u00e9ception 2. b. On suppose que les ultrasons suivent une trajectoire verticale. Calculer la valeur de \\(d\\) .","title":"Exercice"},{"location":"Physique/Seconde/mesure_c_son/#capteur-de-distance","text":"R\u00e9aliser un capteur de distance. Ce capteur donnera une distance en cm. Pour cela, il faut : d\u00e9clarer une autre variable \\(d\\) de type double ; trouver l'expression de la distance \\(d\\) en fonction des autres variables du programme ; Attention aux unit\u00e9s l'afficher \u00e0 l'aide de la fonction Serial.println() .","title":"Capteur de distance"},{"location":"Premiere/cours_juin_1NSI/","text":"Remise \u00e0 niveau : juin 2023 (Support de travail) # Les structures de bases en Python # If else # structure # 1 2 3 4 5 6 d\u00e9but du programme if condition : Bloc1 else : Bloc2 fin du programme op\u00e9rateur de comparaison # Op\u00e9rateur Signification litt\u00e9rale < strictement inf\u00e9rieur \u00e0 > strictement sup\u00e9rieur \u00e0 <= inf\u00e9rieur ou \u00e9gal \u00e0 >= sup\u00e9rieur ou \u00e9gal \u00e0 == \u00e9gal != diff\u00e9rent de Op\u00e9rateur R\u00f4le a and b Vraie si a et b sont vraie a or b vraie si a ou b (ou les deux) sont vraies not(a) si a est vraie, not(a) est fausse et inversement Remarque : une condition peut aussi \u00eatre accol\u00e9e \u00e0 un return dans une fonction. En voici un exemple : fonction est_pair ( a : int ) -> bool : return a % 2 == 0 La boucle while # Structure et fonctionement # On l'utilise lorsque l'on ne sait a priori pas combien de boucles vont \u00eatre effectu\u00e9es. On l'utilise \u00e9galement lorsque l'on veut r\u00e9aliser des incr\u00e9mentations avec un pas qui ne soit pas entier, par exemple lors d'un trac\u00e9 de courbe. La boucle \u00ab tant que \u00bb ex\u00e9cute le corps de boucle (instructions indent\u00e9es) tant qu\u2019une condition \u00e9valu\u00e9e dans le test de poursuite est vraie. D\u00e8s que la condition devient fausse, elle passe aux instructions suivantes. Syntaxe : avec une variable compteur qui va nous servir \u00e0 compter le nombre de boucle. compteur = indice_debut # initialisation de compteur nbre_boucle = indice_fin while compteur < nbre_boucle : # tant que la condition est v\u00e9rifi\u00e9e bloc_instruction compteur += pas # modification de compteur Trace # 1 2 3 4 5 n = 4 r = 0 while r * r <= n : r = r + 1 r = r - 1 N\u00b0 ligne n r Commentaires 1 4 n \\(\\leftarrow\\) 4 2 4 0 r \\(\\leftarrow\\) 0 3 4 0 r*r <= n ? oui, on ex\u00e9cute la ligne 4 4 4 1 r+1 = 0+1 = 1 r \\(\\leftarrow\\) 1 3 4 1 r*r <= n ? oui, on ex\u00e9cute la ligne 4 4 4 2 r+1 = 1+1 = 2 r \\(\\leftarrow\\) 2 3 4 2 r*r <= n ? oui, on ex\u00e9cute la ligne 4 4 4 3 r+1 = 2+1 = 3 r \\(\\leftarrow\\) 2 3 4 3 r*r <= n ? non, on ex\u00e9cute la ligne 5 5 4 2 r-1 = 3 - 1 = 2 r \\(\\leftarrow\\) 2 La boucle for # La boucle for permet d\u2019effectuer un nombre de fois bien d\u00e9termin\u00e9 le corps de boucle (s\u00e9quence d'instructions). Elle s'utilise g\u00e9n\u00e9ralement avec la fonction range qui permet de g\u00e9n\u00e9rer une s\u00e9quence de nombres entiers allant de 0 \u00e0 n exclu. Syntaxe : 1 2 for i in range ( indice_depart , indice_fin , pas ): bloc_instruction Les fonctions # Pour d\u00e9finir un fonction nomm\u00e9e fonction qui prend deux nombres en argument a et b et qui retourne la variable c, on \u00e9crit: 1 2 3 4 5 6 def fonction ( a : type_a , b : type_b ) -> type_c : \"\"\" docstring \"\"\" corps de la fonction return c Exercices # Exercice 1: \u00c9crire un programme qui prend comme argument le rayon(int) et la hauteur(int) du c\u00f4ne et qui calcule et retourne le volume du c\u00f4ne droit. Exercice 2: Faire une fonction qui demande un nombre et qui affiche sa racine carr\u00e9e et son carr\u00e9. Exercice 3 : Faire la trace d\u2019ex\u00e9cution du programme suivant et expliquer ce que fait le programme. Proposer ensuite une mani\u00e8re plus simple d\u2019\u00e9crire la condition de la boucle while, faire \u00e0 nouveau la trace pour v\u00e9rifier que l\u2019on parvient au m\u00eame r\u00e9sultat 1 2 3 4 5 6 7 8 9 a = 24 b = 6 q = 0 while (( a - b ) > 0 or ( b - a ) == 0 ): a = a - b q = q + 1 r = a ; print ( q ) print ( r ) Exercice 4 : Effectuer la trace du programme suivant : 1 2 3 4 5 def fact ( n ): x = 1 for i in range ( 2 , n + 1 ): x = i * x return x Exercice 5: L\u2019\u00abASCII Art\u00bb consiste \u00e0 utiliser les caract\u00e8res alphanum\u00e9riques du code ASCII pour produire des images. Nous allons commencer par dessiner un carr\u00e9 \u00e0 l\u2019aide de la lettre X. \u00c9crire une fonction qui affiche le carr\u00e9 (ci-dessous en taille 8) et qui prend en param\u00e8tre la longueur du c\u00f4t\u00e9. Exercice 6 : A l'aide de la biblioth\u00e8que Turtle, \u00e9crire : une fonction qui r\u00e9alise une carr\u00e9 ; une fonction qui r\u00e9alise un triangle ; une fonction qui r\u00e9alise une maison. Exercice 7 : Un ordinateur manipule des nombres \u00e9crits en binaire : uniquement avec les chiffres \u00ab0\u00bb et \u00ab1\u00bb. Par exemple le nombre 26 s'\u00e9crit 11010 en binaire. Chaque \u00ab0\u00bb et \u00ab1\u00bb d'une \u00e9criture binaire est appel\u00e9 bit. Ainsi, le nombre s'\u00e9crit en binaire sur \\(n\\) bits. Pour savoir combien de bits sont n\u00e9cessaires pour \u00e9crire en binaire un nombre entier strictement positif on compte le nombre de divisions euclidiennes par n\u00e9cessaires pour obtenir un quotient nul. En partant de 26, on a : \\(26 = 2 \\times 13 + 0\\) \\(13 = 2 \\times 6 + 1\\) \\(6 = 2 \\times 3 + 0\\) \\(3 = 2 \\times 1 + 1\\) \\(1 = 2 \\times 0 + 1\\) Comme on peut le voir, 5 divisions euclidiennes ont \u00e9t\u00e9 n\u00e9cessaires pour passer de 26 \u00e0 0 : 26 s'\u00e9crit donc sur 5 bits en binaire. On rappelle que l'op\u00e9rateur // permet d'obtenir le quotient de deux nombres : 13 // 2 est \u00e9valu\u00e9 \u00e0 6. \u00c9crire la fonction nb_bits qui prend en argument un nombre entier strictement positif et renvoie le nombre de bits n\u00e9cessaires \u00e0 son \u00e9criture en binaire. Exercice 8 : Les ann\u00e9es bissextiles comportent 366 jours. Contrairement \u00e0 ce que l'on pense couramment, elles ne se rencontrent pas exactement tous les 4 ans ! En effet : une ann\u00e9e non divisible par 4 n'est pas bissextile ; parmi les ann\u00e9es divisibles par 4 : les ann\u00e9es qui ne sont pas divisibles par 100 sont bissextiles ; parmi les ann\u00e9es divisibles par 100 : les ann\u00e9es qui ne sont pas divisibles par 400 ne sont pas bissextiles, les autres sont bissextiles. Par exemple : 2022 n'est pas divisible par 4 : elle n'est pas bissextile ; 2020 est divisible par 4, mais pas par 100 : elle est bissextile ; 2100 est divisible par 4, par 100, mais pas par 400 : elle n'est pas bissextile ; 2400 est divisible par 4, par 100 et par 400 : elle est bissextile. \u00c9crire la fonction est_bissextile renvoyant True si l'ann\u00e9e pass\u00e9e en argument est bissextile, False dans le cas contraire. Exercice 9 : \u00c9crire la fonction facto qui donne la factorielle d'un nombre \\(n\\) . On rappelle que factorielle de 5 s'\u00e9crit : \\(5! = 5 \\times 4 \\times 3 \\times 2 \\times 1\\) . Exercice 10 : \u00c9crire la fonction somme qui retourne la somme des \\(n\\) premiers entiers. Exemple : somme(5) = 5 + 4 + 3 + 2 + 1 Exercice 11 : Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers \\(n1\\) et \\(n2\\) , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. Exemples : >>> multiplication ( 3 , 5 ) 15 >>> multiplication ( - 4 , - 8 ) 32 >>> multiplication ( - 2 , 6 ) - 12 >>> multiplication ( - 2 , 0 ) 0 Les listes # D\u00e9finitions # Une liste est une structure de donn\u00e9es qui contient une s\u00e9rie de valeurs. Python autorise la construction de liste contenant des valeurs de types diff\u00e9rents (par exemple entier et cha\u00eene de caract\u00e8res), ce qui leur conf\u00e8re une grande flexibilit\u00e9. Une liste est d\u00e9clar\u00e9e par une s\u00e9rie de valeurs (n'oubliez pas les guillemets, simples ou doubles, s'il s'agit de cha\u00eenes de caract\u00e8res) s\u00e9par\u00e9es par des virgules, et le tout encadr\u00e9 par des crochets. En voici quelques exemples : >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> tailles = [ 5 , 2.5 , 1.75 , 0.15 ] >>> mixte = [ \"girafe\" , 5 , \"souris\" , 0.15 ] >>> animaux [ 'girafe' , 'tigre' , 'singe' , 'souris' ] >>> tailles [ 5 , 2.5 , 1.75 , 0.15 ] >>> mixte [ 'girafe' , 5 , 'souris' , 0.15 ] Lorsque l'on affiche une liste, Python la restitue telle qu'elle a \u00e9t\u00e9 saisie. Les instructions utiles # La fonction len() # L'instruction len() permet de conna\u00eetre la longueur d'une liste, c'est-\u00e0-dire le nombre d'\u00e9l\u00e9ments que contient la liste. Voici un exemple d'utilisation : 1 2 3 4 5 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> len ( animaux ) 4 >>> len ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ]) 8 La m\u00e9thode .append() # La m\u00e9thode .append() ajoute un \u00e9l\u00e9ment \u00e0 la fin d'une liste : 1 2 3 4 >>> a = [ 1 , 2 , 3 ] >>> a . append ( 5 ) >>> a [ 1 , 2 , 3 , 5 ] La m\u00e9thode .pop() # La m\u00e9thode .pop() en Python est une fonction qui permet de supprimer un \u00e9l\u00e9ment d'une liste et de renvoyer la valeur de l'\u00e9l\u00e9ment supprim\u00e9. Elle peut prendre un argument optionnel, qui est l'index de l'\u00e9l\u00e9ment \u00e0 supprimer. Si aucun index n'est sp\u00e9cifi\u00e9, la m\u00e9thode pop() supprimera et renverra le dernier \u00e9l\u00e9ment de la liste. 1 2 3 4 5 6 7 8 9 10 11 a = [ 1 , 2 , 3 , 4 , 5 ] element = a . pop () print ( a ) print ( element ) \"\"\" Cela imprimera: [1, 2, 3, 4] 5 \"\"\" La fonction del # L'instruction del supprime un \u00e9l\u00e9ment d'une liste \u00e0 un indice d\u00e9termin\u00e9 : 1 2 3 4 >>> a = [ 1 , 2 , 3 ] >>> del a [ 1 ] >>> a [ 1 , 3 ] La m\u00e9thode remove() # La m\u00e9thode .remove() supprime un \u00e9l\u00e9ment d'une liste \u00e0 partir de sa valeur : 1 2 3 4 5 6 7 >>> a = [ 1 , 2 , 3 , 4 , 3 ] >>> a . remove ( 3 ) >>> a [ 1 , 2 , 4 , 3 ] >>> a . remove ( 3 ) >>> a [ 1 , 2 , 4 ] La m\u00e9thode .reverse() # La m\u00e9thode .reverse() inverse une liste : 1 2 3 4 >>> a = [ 3 , 1 , 2 ] >>> a . reverse () >>> a [ 2 , 1 , 3 ] Balayage d'une liste # Balayage par indice # 1 2 3 4 a = [ 3 , 1 , 2 ] for i in range ( len ( a )): print ( i ) # affichera 0,1,2 print ( a [ i ]) # affichera 3,1,2 Balayage par \u00e9l\u00e9ment # 1 2 3 a = [ 3 , 1 , 2 ] for i in a : print ( i ) # affichera 3,1,2 Exercices # Exercice 1 : \u00c9crire une fonction genereTab qui prend en argument 2 entiers et retourne un tableau de longueur \u00e9gale au 1 er argument et dont chaque \u00e9l\u00e9ment est un nombre entier al\u00e9atoire compris entre 0 et le 2 nd argument (inclus). Exercice 2 : \u00c9crire une fonction moyenne qui prend en argument une liste contenant les notes. La fonction retournera la moyenne des notes. Exercice 3 : \u00c9crire une fonction carre(n) qui renvoie le tableau des carr\u00e9s des nombres entiers compris entre 0 et n-1. Exercice 4 : \u00c9crire une fonction imagesf(deb,fin) qui renvoie le tableau des images des nombres entiers compris entre deb et fin par la fonction \\(f:x \\rightarrow 3x^2 - 2x + 1\\) Exercice 5 : Programmer la fonction derniere_occurrence , prenant en param\u00e8tre un tableau non vide d'entiers et un entier cible, et qui renvoie l'indice de la derni\u00e8re occurrence de cible. Si l'\u00e9l\u00e9ment n'est pas pr\u00e9sent, la fonction renvoie la longueur du tableau. Exercice 6 : \u00c9crire les fonctions suivants : Maximum : d\u00e9terminer le maximum dans un tableau ; Indice du minimum : d\u00e9terminer l'indice du minimum dans un tableau ; Premier minimum local : d\u00e9terminer l'indice du premier minimum dans un tableau ; Occurrences du minimum : d\u00e9terminer la valeur et les indices du minimum ; Valeur et indices du max : d\u00e9terminer la valeur et les indices du maximum. Les dictionnaires # D\u00e9finition # Comme on l\u2019a vu avec les listes \u00e0 partir des types de base (int, float, etc.) il est possible d\u2019\u00e9laborer de nouveaux types qu\u2019on appelle des types construits. Un nouvel exemple de type construit est le dictionnaire. Les \u00e9l\u00e9ments d\u2019une liste ou d\u2019un tuple sont ordonn\u00e9s et on acc\u00e9de \u00e0 un \u00e9l\u00e9ment gr\u00e2ce \u00e0 sa position en utilisant un num\u00e9ro qu\u2019on appelle l\u2019indice de l\u2019\u00e9l\u00e9ment. Un dictionnaire en Python va aussi permettre de rassembler des \u00e9l\u00e9ments mais ceux-ci seront identifi\u00e9s par une cl\u00e9. On peut faire l\u2019analogie avec un dictionnaire de fran\u00e7ais o\u00f9 on acc\u00e8de \u00e0 une d\u00e9finition avec un mot. Contrairement aux listes qui sont d\u00e9limit\u00e9es par des crochets, on utilise des accolades pour les dictionnaires. 1 mon_dictionnaire = { \"voiture\" : \"v\u00e9hicule \u00e0 quatre roues\" , \"v\u00e9lo\" : \"v\u00e9hicule \u00e0 deux roues\" } Un \u00e9l\u00e9ment a \u00e9t\u00e9 d\u00e9fini ci-dessus dans le dictionnaire en pr\u00e9cisant une cl\u00e9 au moyen d\u2019une cha\u00eene de caract\u00e8res suivie de : puis de la valeur associ\u00e9e cl\u00e9: valeur On acc\u00e8de \u00e0 une valeur du dictionnaire en utilisant la cl\u00e9 entour\u00e9e par des crochets avec la syntaxe suivante : 1 2 mon_dictionnaire [ \"voiture\" ] # ->'v\u00e9hicule \u00e0 quatre roues' Exercices # Exercice 1 : Sur le r\u00e9seau social TipTop, on s\u2019int\u00e9resse au nombre de \u00ab like \u00bb des abonn\u00e9s. Les donn\u00e9es sont stock\u00e9es dans des dictionnaires o\u00f9 les cl\u00e9s sont les pseudos et les valeurs correspondantes sont les nombres de \u00ab like \u00bb comme ci-dessous : {'Bob': 102, 'Ada': 201, 'Alice': 103, 'Tim': 50} \u00c9crire une fonction max_dico qui : Prend en param\u00e8tre un dictionnaire dico non vide dont les cl\u00e9s sont des cha\u00eenes de caract\u00e8res et les valeurs associ\u00e9es sont des entiers ; Renvoie un tuple dont : La premi\u00e8re valeur est la cl\u00e9 du dictionnaire associ\u00e9e \u00e0 la valeur maximale ; La seconde valeur est la premi\u00e8re valeur maximale pr\u00e9sente dans le dictionnaire. Exemples : 1 2 3 4 >>> max_dico ({ 'Bob' : 102 , 'Ada' : 201 , 'Alice' : 103 , 'Tim' : 50 }) ( 'Ada' , 201 ) >>> max_dico ({ 'Alan' : 222 , 'Ada' : 201 , 'Eve' : 220 , 'Tim' : 50 }) ( 'Alan' , 222 ) Bibliographie # Site de Gilles Lassus Side de David Roche e-nsi : : exercices pratiques Zone NSI","title":"Rappels"},{"location":"Premiere/cours_juin_1NSI/#remise-a-niveau-juin-2023-support-de-travail","text":"","title":"Remise \u00e0 niveau : juin 2023 (Support de travail)"},{"location":"Premiere/cours_juin_1NSI/#les-structures-de-bases-en-python","text":"","title":"Les structures de bases en Python"},{"location":"Premiere/cours_juin_1NSI/#if-else","text":"","title":"If else"},{"location":"Premiere/cours_juin_1NSI/#structure","text":"1 2 3 4 5 6 d\u00e9but du programme if condition : Bloc1 else : Bloc2 fin du programme","title":"structure"},{"location":"Premiere/cours_juin_1NSI/#operateur-de-comparaison","text":"Op\u00e9rateur Signification litt\u00e9rale < strictement inf\u00e9rieur \u00e0 > strictement sup\u00e9rieur \u00e0 <= inf\u00e9rieur ou \u00e9gal \u00e0 >= sup\u00e9rieur ou \u00e9gal \u00e0 == \u00e9gal != diff\u00e9rent de Op\u00e9rateur R\u00f4le a and b Vraie si a et b sont vraie a or b vraie si a ou b (ou les deux) sont vraies not(a) si a est vraie, not(a) est fausse et inversement Remarque : une condition peut aussi \u00eatre accol\u00e9e \u00e0 un return dans une fonction. En voici un exemple : fonction est_pair ( a : int ) -> bool : return a % 2 == 0","title":"op\u00e9rateur de comparaison"},{"location":"Premiere/cours_juin_1NSI/#la-boucle-while","text":"","title":"La boucle while"},{"location":"Premiere/cours_juin_1NSI/#structure-et-fonctionement","text":"On l'utilise lorsque l'on ne sait a priori pas combien de boucles vont \u00eatre effectu\u00e9es. On l'utilise \u00e9galement lorsque l'on veut r\u00e9aliser des incr\u00e9mentations avec un pas qui ne soit pas entier, par exemple lors d'un trac\u00e9 de courbe. La boucle \u00ab tant que \u00bb ex\u00e9cute le corps de boucle (instructions indent\u00e9es) tant qu\u2019une condition \u00e9valu\u00e9e dans le test de poursuite est vraie. D\u00e8s que la condition devient fausse, elle passe aux instructions suivantes. Syntaxe : avec une variable compteur qui va nous servir \u00e0 compter le nombre de boucle. compteur = indice_debut # initialisation de compteur nbre_boucle = indice_fin while compteur < nbre_boucle : # tant que la condition est v\u00e9rifi\u00e9e bloc_instruction compteur += pas # modification de compteur","title":"Structure et fonctionement"},{"location":"Premiere/cours_juin_1NSI/#trace","text":"1 2 3 4 5 n = 4 r = 0 while r * r <= n : r = r + 1 r = r - 1 N\u00b0 ligne n r Commentaires 1 4 n \\(\\leftarrow\\) 4 2 4 0 r \\(\\leftarrow\\) 0 3 4 0 r*r <= n ? oui, on ex\u00e9cute la ligne 4 4 4 1 r+1 = 0+1 = 1 r \\(\\leftarrow\\) 1 3 4 1 r*r <= n ? oui, on ex\u00e9cute la ligne 4 4 4 2 r+1 = 1+1 = 2 r \\(\\leftarrow\\) 2 3 4 2 r*r <= n ? oui, on ex\u00e9cute la ligne 4 4 4 3 r+1 = 2+1 = 3 r \\(\\leftarrow\\) 2 3 4 3 r*r <= n ? non, on ex\u00e9cute la ligne 5 5 4 2 r-1 = 3 - 1 = 2 r \\(\\leftarrow\\) 2","title":"Trace"},{"location":"Premiere/cours_juin_1NSI/#la-boucle-for","text":"La boucle for permet d\u2019effectuer un nombre de fois bien d\u00e9termin\u00e9 le corps de boucle (s\u00e9quence d'instructions). Elle s'utilise g\u00e9n\u00e9ralement avec la fonction range qui permet de g\u00e9n\u00e9rer une s\u00e9quence de nombres entiers allant de 0 \u00e0 n exclu. Syntaxe : 1 2 for i in range ( indice_depart , indice_fin , pas ): bloc_instruction","title":"La boucle for"},{"location":"Premiere/cours_juin_1NSI/#les-fonctions","text":"Pour d\u00e9finir un fonction nomm\u00e9e fonction qui prend deux nombres en argument a et b et qui retourne la variable c, on \u00e9crit: 1 2 3 4 5 6 def fonction ( a : type_a , b : type_b ) -> type_c : \"\"\" docstring \"\"\" corps de la fonction return c","title":"Les fonctions"},{"location":"Premiere/cours_juin_1NSI/#exercices","text":"Exercice 1: \u00c9crire un programme qui prend comme argument le rayon(int) et la hauteur(int) du c\u00f4ne et qui calcule et retourne le volume du c\u00f4ne droit. Exercice 2: Faire une fonction qui demande un nombre et qui affiche sa racine carr\u00e9e et son carr\u00e9. Exercice 3 : Faire la trace d\u2019ex\u00e9cution du programme suivant et expliquer ce que fait le programme. Proposer ensuite une mani\u00e8re plus simple d\u2019\u00e9crire la condition de la boucle while, faire \u00e0 nouveau la trace pour v\u00e9rifier que l\u2019on parvient au m\u00eame r\u00e9sultat 1 2 3 4 5 6 7 8 9 a = 24 b = 6 q = 0 while (( a - b ) > 0 or ( b - a ) == 0 ): a = a - b q = q + 1 r = a ; print ( q ) print ( r ) Exercice 4 : Effectuer la trace du programme suivant : 1 2 3 4 5 def fact ( n ): x = 1 for i in range ( 2 , n + 1 ): x = i * x return x Exercice 5: L\u2019\u00abASCII Art\u00bb consiste \u00e0 utiliser les caract\u00e8res alphanum\u00e9riques du code ASCII pour produire des images. Nous allons commencer par dessiner un carr\u00e9 \u00e0 l\u2019aide de la lettre X. \u00c9crire une fonction qui affiche le carr\u00e9 (ci-dessous en taille 8) et qui prend en param\u00e8tre la longueur du c\u00f4t\u00e9. Exercice 6 : A l'aide de la biblioth\u00e8que Turtle, \u00e9crire : une fonction qui r\u00e9alise une carr\u00e9 ; une fonction qui r\u00e9alise un triangle ; une fonction qui r\u00e9alise une maison. Exercice 7 : Un ordinateur manipule des nombres \u00e9crits en binaire : uniquement avec les chiffres \u00ab0\u00bb et \u00ab1\u00bb. Par exemple le nombre 26 s'\u00e9crit 11010 en binaire. Chaque \u00ab0\u00bb et \u00ab1\u00bb d'une \u00e9criture binaire est appel\u00e9 bit. Ainsi, le nombre s'\u00e9crit en binaire sur \\(n\\) bits. Pour savoir combien de bits sont n\u00e9cessaires pour \u00e9crire en binaire un nombre entier strictement positif on compte le nombre de divisions euclidiennes par n\u00e9cessaires pour obtenir un quotient nul. En partant de 26, on a : \\(26 = 2 \\times 13 + 0\\) \\(13 = 2 \\times 6 + 1\\) \\(6 = 2 \\times 3 + 0\\) \\(3 = 2 \\times 1 + 1\\) \\(1 = 2 \\times 0 + 1\\) Comme on peut le voir, 5 divisions euclidiennes ont \u00e9t\u00e9 n\u00e9cessaires pour passer de 26 \u00e0 0 : 26 s'\u00e9crit donc sur 5 bits en binaire. On rappelle que l'op\u00e9rateur // permet d'obtenir le quotient de deux nombres : 13 // 2 est \u00e9valu\u00e9 \u00e0 6. \u00c9crire la fonction nb_bits qui prend en argument un nombre entier strictement positif et renvoie le nombre de bits n\u00e9cessaires \u00e0 son \u00e9criture en binaire. Exercice 8 : Les ann\u00e9es bissextiles comportent 366 jours. Contrairement \u00e0 ce que l'on pense couramment, elles ne se rencontrent pas exactement tous les 4 ans ! En effet : une ann\u00e9e non divisible par 4 n'est pas bissextile ; parmi les ann\u00e9es divisibles par 4 : les ann\u00e9es qui ne sont pas divisibles par 100 sont bissextiles ; parmi les ann\u00e9es divisibles par 100 : les ann\u00e9es qui ne sont pas divisibles par 400 ne sont pas bissextiles, les autres sont bissextiles. Par exemple : 2022 n'est pas divisible par 4 : elle n'est pas bissextile ; 2020 est divisible par 4, mais pas par 100 : elle est bissextile ; 2100 est divisible par 4, par 100, mais pas par 400 : elle n'est pas bissextile ; 2400 est divisible par 4, par 100 et par 400 : elle est bissextile. \u00c9crire la fonction est_bissextile renvoyant True si l'ann\u00e9e pass\u00e9e en argument est bissextile, False dans le cas contraire. Exercice 9 : \u00c9crire la fonction facto qui donne la factorielle d'un nombre \\(n\\) . On rappelle que factorielle de 5 s'\u00e9crit : \\(5! = 5 \\times 4 \\times 3 \\times 2 \\times 1\\) . Exercice 10 : \u00c9crire la fonction somme qui retourne la somme des \\(n\\) premiers entiers. Exemple : somme(5) = 5 + 4 + 3 + 2 + 1 Exercice 11 : Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers \\(n1\\) et \\(n2\\) , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. Exemples : >>> multiplication ( 3 , 5 ) 15 >>> multiplication ( - 4 , - 8 ) 32 >>> multiplication ( - 2 , 6 ) - 12 >>> multiplication ( - 2 , 0 ) 0","title":"Exercices"},{"location":"Premiere/cours_juin_1NSI/#les-listes","text":"","title":"Les listes"},{"location":"Premiere/cours_juin_1NSI/#definitions","text":"Une liste est une structure de donn\u00e9es qui contient une s\u00e9rie de valeurs. Python autorise la construction de liste contenant des valeurs de types diff\u00e9rents (par exemple entier et cha\u00eene de caract\u00e8res), ce qui leur conf\u00e8re une grande flexibilit\u00e9. Une liste est d\u00e9clar\u00e9e par une s\u00e9rie de valeurs (n'oubliez pas les guillemets, simples ou doubles, s'il s'agit de cha\u00eenes de caract\u00e8res) s\u00e9par\u00e9es par des virgules, et le tout encadr\u00e9 par des crochets. En voici quelques exemples : >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> tailles = [ 5 , 2.5 , 1.75 , 0.15 ] >>> mixte = [ \"girafe\" , 5 , \"souris\" , 0.15 ] >>> animaux [ 'girafe' , 'tigre' , 'singe' , 'souris' ] >>> tailles [ 5 , 2.5 , 1.75 , 0.15 ] >>> mixte [ 'girafe' , 5 , 'souris' , 0.15 ] Lorsque l'on affiche une liste, Python la restitue telle qu'elle a \u00e9t\u00e9 saisie.","title":"D\u00e9finitions"},{"location":"Premiere/cours_juin_1NSI/#les-instructions-utiles","text":"","title":"Les instructions utiles"},{"location":"Premiere/cours_juin_1NSI/#la-fonction-len","text":"L'instruction len() permet de conna\u00eetre la longueur d'une liste, c'est-\u00e0-dire le nombre d'\u00e9l\u00e9ments que contient la liste. Voici un exemple d'utilisation : 1 2 3 4 5 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> len ( animaux ) 4 >>> len ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ]) 8","title":"La fonction len()"},{"location":"Premiere/cours_juin_1NSI/#la-methode-append","text":"La m\u00e9thode .append() ajoute un \u00e9l\u00e9ment \u00e0 la fin d'une liste : 1 2 3 4 >>> a = [ 1 , 2 , 3 ] >>> a . append ( 5 ) >>> a [ 1 , 2 , 3 , 5 ]","title":"La m\u00e9thode .append()"},{"location":"Premiere/cours_juin_1NSI/#la-methode-pop","text":"La m\u00e9thode .pop() en Python est une fonction qui permet de supprimer un \u00e9l\u00e9ment d'une liste et de renvoyer la valeur de l'\u00e9l\u00e9ment supprim\u00e9. Elle peut prendre un argument optionnel, qui est l'index de l'\u00e9l\u00e9ment \u00e0 supprimer. Si aucun index n'est sp\u00e9cifi\u00e9, la m\u00e9thode pop() supprimera et renverra le dernier \u00e9l\u00e9ment de la liste. 1 2 3 4 5 6 7 8 9 10 11 a = [ 1 , 2 , 3 , 4 , 5 ] element = a . pop () print ( a ) print ( element ) \"\"\" Cela imprimera: [1, 2, 3, 4] 5 \"\"\"","title":"La m\u00e9thode .pop()"},{"location":"Premiere/cours_juin_1NSI/#la-fonction-del","text":"L'instruction del supprime un \u00e9l\u00e9ment d'une liste \u00e0 un indice d\u00e9termin\u00e9 : 1 2 3 4 >>> a = [ 1 , 2 , 3 ] >>> del a [ 1 ] >>> a [ 1 , 3 ]","title":"La fonction del"},{"location":"Premiere/cours_juin_1NSI/#la-methode-remove","text":"La m\u00e9thode .remove() supprime un \u00e9l\u00e9ment d'une liste \u00e0 partir de sa valeur : 1 2 3 4 5 6 7 >>> a = [ 1 , 2 , 3 , 4 , 3 ] >>> a . remove ( 3 ) >>> a [ 1 , 2 , 4 , 3 ] >>> a . remove ( 3 ) >>> a [ 1 , 2 , 4 ]","title":"La m\u00e9thode remove()"},{"location":"Premiere/cours_juin_1NSI/#la-methode-reverse","text":"La m\u00e9thode .reverse() inverse une liste : 1 2 3 4 >>> a = [ 3 , 1 , 2 ] >>> a . reverse () >>> a [ 2 , 1 , 3 ]","title":"La m\u00e9thode .reverse()"},{"location":"Premiere/cours_juin_1NSI/#balayage-dune-liste","text":"","title":"Balayage d'une liste"},{"location":"Premiere/cours_juin_1NSI/#balayage-par-indice","text":"1 2 3 4 a = [ 3 , 1 , 2 ] for i in range ( len ( a )): print ( i ) # affichera 0,1,2 print ( a [ i ]) # affichera 3,1,2","title":"Balayage par indice"},{"location":"Premiere/cours_juin_1NSI/#balayage-par-element","text":"1 2 3 a = [ 3 , 1 , 2 ] for i in a : print ( i ) # affichera 3,1,2","title":"Balayage par \u00e9l\u00e9ment"},{"location":"Premiere/cours_juin_1NSI/#exercices_1","text":"Exercice 1 : \u00c9crire une fonction genereTab qui prend en argument 2 entiers et retourne un tableau de longueur \u00e9gale au 1 er argument et dont chaque \u00e9l\u00e9ment est un nombre entier al\u00e9atoire compris entre 0 et le 2 nd argument (inclus). Exercice 2 : \u00c9crire une fonction moyenne qui prend en argument une liste contenant les notes. La fonction retournera la moyenne des notes. Exercice 3 : \u00c9crire une fonction carre(n) qui renvoie le tableau des carr\u00e9s des nombres entiers compris entre 0 et n-1. Exercice 4 : \u00c9crire une fonction imagesf(deb,fin) qui renvoie le tableau des images des nombres entiers compris entre deb et fin par la fonction \\(f:x \\rightarrow 3x^2 - 2x + 1\\) Exercice 5 : Programmer la fonction derniere_occurrence , prenant en param\u00e8tre un tableau non vide d'entiers et un entier cible, et qui renvoie l'indice de la derni\u00e8re occurrence de cible. Si l'\u00e9l\u00e9ment n'est pas pr\u00e9sent, la fonction renvoie la longueur du tableau. Exercice 6 : \u00c9crire les fonctions suivants : Maximum : d\u00e9terminer le maximum dans un tableau ; Indice du minimum : d\u00e9terminer l'indice du minimum dans un tableau ; Premier minimum local : d\u00e9terminer l'indice du premier minimum dans un tableau ; Occurrences du minimum : d\u00e9terminer la valeur et les indices du minimum ; Valeur et indices du max : d\u00e9terminer la valeur et les indices du maximum.","title":"Exercices"},{"location":"Premiere/cours_juin_1NSI/#les-dictionnaires","text":"","title":"Les dictionnaires"},{"location":"Premiere/cours_juin_1NSI/#definition","text":"Comme on l\u2019a vu avec les listes \u00e0 partir des types de base (int, float, etc.) il est possible d\u2019\u00e9laborer de nouveaux types qu\u2019on appelle des types construits. Un nouvel exemple de type construit est le dictionnaire. Les \u00e9l\u00e9ments d\u2019une liste ou d\u2019un tuple sont ordonn\u00e9s et on acc\u00e9de \u00e0 un \u00e9l\u00e9ment gr\u00e2ce \u00e0 sa position en utilisant un num\u00e9ro qu\u2019on appelle l\u2019indice de l\u2019\u00e9l\u00e9ment. Un dictionnaire en Python va aussi permettre de rassembler des \u00e9l\u00e9ments mais ceux-ci seront identifi\u00e9s par une cl\u00e9. On peut faire l\u2019analogie avec un dictionnaire de fran\u00e7ais o\u00f9 on acc\u00e8de \u00e0 une d\u00e9finition avec un mot. Contrairement aux listes qui sont d\u00e9limit\u00e9es par des crochets, on utilise des accolades pour les dictionnaires. 1 mon_dictionnaire = { \"voiture\" : \"v\u00e9hicule \u00e0 quatre roues\" , \"v\u00e9lo\" : \"v\u00e9hicule \u00e0 deux roues\" } Un \u00e9l\u00e9ment a \u00e9t\u00e9 d\u00e9fini ci-dessus dans le dictionnaire en pr\u00e9cisant une cl\u00e9 au moyen d\u2019une cha\u00eene de caract\u00e8res suivie de : puis de la valeur associ\u00e9e cl\u00e9: valeur On acc\u00e8de \u00e0 une valeur du dictionnaire en utilisant la cl\u00e9 entour\u00e9e par des crochets avec la syntaxe suivante : 1 2 mon_dictionnaire [ \"voiture\" ] # ->'v\u00e9hicule \u00e0 quatre roues'","title":"D\u00e9finition"},{"location":"Premiere/cours_juin_1NSI/#exercices_2","text":"Exercice 1 : Sur le r\u00e9seau social TipTop, on s\u2019int\u00e9resse au nombre de \u00ab like \u00bb des abonn\u00e9s. Les donn\u00e9es sont stock\u00e9es dans des dictionnaires o\u00f9 les cl\u00e9s sont les pseudos et les valeurs correspondantes sont les nombres de \u00ab like \u00bb comme ci-dessous : {'Bob': 102, 'Ada': 201, 'Alice': 103, 'Tim': 50} \u00c9crire une fonction max_dico qui : Prend en param\u00e8tre un dictionnaire dico non vide dont les cl\u00e9s sont des cha\u00eenes de caract\u00e8res et les valeurs associ\u00e9es sont des entiers ; Renvoie un tuple dont : La premi\u00e8re valeur est la cl\u00e9 du dictionnaire associ\u00e9e \u00e0 la valeur maximale ; La seconde valeur est la premi\u00e8re valeur maximale pr\u00e9sente dans le dictionnaire. Exemples : 1 2 3 4 >>> max_dico ({ 'Bob' : 102 , 'Ada' : 201 , 'Alice' : 103 , 'Tim' : 50 }) ( 'Ada' , 201 ) >>> max_dico ({ 'Alan' : 222 , 'Ada' : 201 , 'Eve' : 220 , 'Tim' : 50 }) ( 'Alan' , 222 )","title":"Exercices"},{"location":"Premiere/cours_juin_1NSI/#bibliographie","text":"Site de Gilles Lassus Side de David Roche e-nsi : : exercices pratiques Zone NSI","title":"Bibliographie"},{"location":"Premiere/kppv/","text":"Algorithme des plus proches voisins # Introduction # Dans ce chapitre, nous allons travailler avec un algorithme d'apprentissage automatique, souvent appel\u00e9 un algorithme de machine learning. Le principe de ces algorithmes est d'utiliser un grand nombre de donn\u00e9es afin \"d'apprendre \u00e0 la machine\" \u00e0 r\u00e9soudre des probl\u00e8mes. Bien que cette id\u00e9e d'apprentissage automatique date de la fin des ann\u00e9es 1950, le machine learning a pris toute son importance avec la mont\u00e9e en puissance du Big Data, offrant des quantit\u00e9s de donn\u00e9es \u00e0 analyser sur d'innombrables sujets. \u00c0 noter aussi l'importance des strat\u00e9gies mises en place par les GAFAM (Google, Apple, Facebook, Amazon et Microsoft) afin de r\u00e9cup\u00e9rer un grand nombre de donn\u00e9es concernant leurs clients. Ces donn\u00e9es sont tr\u00e8s souvent utilis\u00e9es pour alimenter des algorithmes de machine learning (ce qui permet par exemple \u00e0 Amazon de proposer \u00e0 ces clients des \"suggestions d'achats\" souvent tr\u00e8s pertinentes). Les donn\u00e9es d'Edgar Anderson relatives aux diff\u00e9rentes esp\u00e8ces d'iris # En 1936, Edgar Anderson a collect\u00e9 des donn\u00e9es sur 3 esp\u00e8ces d'iris : \"iris setosa\", \"iris virginica\" et \"iris versicolor\". Pour chaque iris \u00e9tudi\u00e9, Anderson a mesur\u00e9 la largeur et la longueur des s\u00e9pales, la largeur et la longueur des p\u00e9tales. Par souci de simplification, nous nous int\u00e9resserons uniquement \u00e0 la largeur et \u00e0 la longueur des p\u00e9tales. 50 de ces mesures se trouvent dans le fichier iris.csv t\u00e9l\u00e9chargeable depuis le groupe de travail sur l'ENT. Ce jeu de donn\u00e9es pr\u00e9sente aujourd'hui un int\u00e9r\u00eat essentiellement p\u00e9dagogique. En effet, il est exclusivement utilis\u00e9 par des personnes d\u00e9sirant s'initier aux algorithmes de machine learning. transistor Les valeurs du champ \"species\"(\"esp\u00e8ces\")sont 0 pour l'esp\u00e8ce \"setosa\", 1 pour \"virginica\" et 2 pour\"versicolor\". Nous allons dans un premier temps r\u00e9aliser une repr\u00e9sentation graphique des donn\u00e9es contenues dans le fichier \u00e0 l'aide du script python suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import pandas import matplotlib.pyplot as plt plt . figure () iris = pandas . read_csv ( \"iris.csv\" ) #lecture du fichier iris.csc x = iris . loc [:, \"petal_length\" ] #extraction de la longueur du p\u00e9tale y = iris . loc [:, \"petal_width\" ] #extraction de la largeur du p\u00e9tale espece = iris . loc [:, \"species\" ] plt . scatter ( x [ espece == 0 ], y [ espece == 0 ], color = 'g' , label = 'setosa' ) #trac\u00e9 pour la setosa plt . scatter ( x [ espece == 1 ], y [ espece == 1 ], color = 'r' , label = 'versicolor' ) plt . scatter ( x [ espece == 2 ], y [ espece == 2 ], color = 'b' , label = 'virginica' ) plt . legend () #affichage de la l\u00e9gende plt . show () # affichage du graphique On constate que ces points sont regroup\u00e9s par esp\u00e8ces d'iris. Exercice 1 : Ouvrir l'activit\u00e9 Capytale n\u00b0 : c0d5-1738910 ; Copier/coller le code pr\u00e9c\u00e9dent et ex\u00e9cuter-le. Modifier ce code et observer. Comment apprendre \u00e0 reconna\u00eetre une esp\u00e8ce d'iris # Consid\u00e9rons maintenant une iris dont les p\u00e9tales mesurent 0,5 cm de large et 2 cm de long. Comment d\u00e9terminer l'esp\u00e8ce \u00e0 laquelle cette iris appartient ? Afin de r\u00e9pondre \u00e0 cette probl\u00e9matique, nous allons placer cette nouvelle donn\u00e9e sur le graphique: 1 plt . scatter ( 2.0 , 0.5 , color = \"black\" ) Dans ce cas, on voit clairement qu'il y a de fortes chances pour que l'iris soit de l'esp\u00e8ce \"setosa\". Cependant, il existe des cas o\u00f9 il est beaucoup plus difficile de r\u00e9pondre, par exemple pour une iris dont les p\u00e9tales mesurent 0,75 cm de large et 2,5 cm de long. Afin de d\u00e9terminer si l'iris appartient \u00e0 l'esp\u00e8ce \"s\u00e9tosa\" ou \u00e0 l'esp\u00e8ce \"virginica\", nous allons devoir utiliser l'algorithme des k plus proches voisins. Exercice 2 : R\u00e9aliser sur cette activit\u00e9 capytale le code pour ins\u00e9rer l'iris inconnu. Algorithme des k plus proches voisins # Quel est le principe de cet algorithme ? On calcule la distance entre le point correspondant \u00e0 l'iris inconnu et chaque point issu du jeu de donn\u00e9es \"iris\" ; On s\u00e9lectionne les k distances les plus petites (les k plus proches voisins) ; Parmi les k plus proches voisins, on d\u00e9termine quelle est l'esp\u00e8ce majoritaire, et on attribue \u00e0 notre iris inconnu cette esp\u00e8ce majoritaire. Prenons k = 3 : Les 3 plus proches voisins sont deux \"setosa\" et un \"virginica\". D'apr\u00e8s l'algorithme des \"k plus proches voisins\", notre iris inconnue appartient \u00e0 l'esp\u00e8ce \"setosa\". La biblioth\u00e8que Python Scikit Learn propose un grand nombre d'algorithmes li\u00e9 au machine learning (c'est sans aucun doute la biblioth\u00e8que la plus utilis\u00e9e en machine learning). Parmi tous ces algorithmes, Scikit Learn propose l'algorithme des k plus proches voisins. Importer la biblioth\u00e8que: 1 from sklearn.neighbors import KNeighborsClassifier Compl\u00e9ter le programme pr\u00e9c\u00e9dent (la fonction plt.show() devra \u00eatre plac\u00e9e en fin de script): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 k = 3 #nbre de plus proches voisins #donn\u00e9es concernant l'iris inconnu longueur = 2 , 5 largeur = 0.75 #algo knn d = list ( zip ( x , y )) #permet de passer des 2 listes x et y (x = [1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, ...] #y = [0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.4,....] \u00e0 une liste de tuples #d = [(1.4, 0.2), (1.4, 0.2), (1.3, 0.2) (1.5, 0.2), (1.4, 0.2), (1.7, 0.2), (1.4, 0.4), ...] model = KNeighborsClassifier ( n_neighbors = k ) #\"KNeighborsClassifier\" est une m\u00e9thode issue #de la biblioth\u00e8que scikit-learn model . fit ( d , espece ) prediction = model . predict ([[ longueur , largeur ]]) #fin algo knn #Affichage r\u00e9sultats txt = \"R\u00e9sultat : \" if prediction [ 0 ] == 0 : txt = txt + \"setosa\" if prediction [ 0 ] == 2 : txt = txt + \"virginica\" if prediction [ 0 ] == 1 : txt = txt + \"versicolor\" plt . text ( 4 , 0.5 , txt , fontsize = 12 ) Exercice 3 : Sur cette activit\u00e9 Capytale, r\u00e9aliser le script afin de d\u00e9terminer l'esp\u00e8ce de l'iris inconnu. Exercice 4 : Le r\u00e9sultat d\u00e9pend-t-il du nombre de voisins ? Pour r\u00e9pondre \u00e0 cette question, relancer le script en prenant toujours le m\u00eame iris inconnu mais en faisant varier le nombre de voisins. Que constatez-vous ?","title":"kppv"},{"location":"Premiere/kppv/#algorithme-des-plus-proches-voisins","text":"","title":"Algorithme des plus proches voisins"},{"location":"Premiere/kppv/#introduction","text":"Dans ce chapitre, nous allons travailler avec un algorithme d'apprentissage automatique, souvent appel\u00e9 un algorithme de machine learning. Le principe de ces algorithmes est d'utiliser un grand nombre de donn\u00e9es afin \"d'apprendre \u00e0 la machine\" \u00e0 r\u00e9soudre des probl\u00e8mes. Bien que cette id\u00e9e d'apprentissage automatique date de la fin des ann\u00e9es 1950, le machine learning a pris toute son importance avec la mont\u00e9e en puissance du Big Data, offrant des quantit\u00e9s de donn\u00e9es \u00e0 analyser sur d'innombrables sujets. \u00c0 noter aussi l'importance des strat\u00e9gies mises en place par les GAFAM (Google, Apple, Facebook, Amazon et Microsoft) afin de r\u00e9cup\u00e9rer un grand nombre de donn\u00e9es concernant leurs clients. Ces donn\u00e9es sont tr\u00e8s souvent utilis\u00e9es pour alimenter des algorithmes de machine learning (ce qui permet par exemple \u00e0 Amazon de proposer \u00e0 ces clients des \"suggestions d'achats\" souvent tr\u00e8s pertinentes).","title":"Introduction"},{"location":"Premiere/kppv/#les-donnees-dedgar-anderson-relatives-aux-differentes-especes-diris","text":"En 1936, Edgar Anderson a collect\u00e9 des donn\u00e9es sur 3 esp\u00e8ces d'iris : \"iris setosa\", \"iris virginica\" et \"iris versicolor\". Pour chaque iris \u00e9tudi\u00e9, Anderson a mesur\u00e9 la largeur et la longueur des s\u00e9pales, la largeur et la longueur des p\u00e9tales. Par souci de simplification, nous nous int\u00e9resserons uniquement \u00e0 la largeur et \u00e0 la longueur des p\u00e9tales. 50 de ces mesures se trouvent dans le fichier iris.csv t\u00e9l\u00e9chargeable depuis le groupe de travail sur l'ENT. Ce jeu de donn\u00e9es pr\u00e9sente aujourd'hui un int\u00e9r\u00eat essentiellement p\u00e9dagogique. En effet, il est exclusivement utilis\u00e9 par des personnes d\u00e9sirant s'initier aux algorithmes de machine learning. transistor Les valeurs du champ \"species\"(\"esp\u00e8ces\")sont 0 pour l'esp\u00e8ce \"setosa\", 1 pour \"virginica\" et 2 pour\"versicolor\". Nous allons dans un premier temps r\u00e9aliser une repr\u00e9sentation graphique des donn\u00e9es contenues dans le fichier \u00e0 l'aide du script python suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import pandas import matplotlib.pyplot as plt plt . figure () iris = pandas . read_csv ( \"iris.csv\" ) #lecture du fichier iris.csc x = iris . loc [:, \"petal_length\" ] #extraction de la longueur du p\u00e9tale y = iris . loc [:, \"petal_width\" ] #extraction de la largeur du p\u00e9tale espece = iris . loc [:, \"species\" ] plt . scatter ( x [ espece == 0 ], y [ espece == 0 ], color = 'g' , label = 'setosa' ) #trac\u00e9 pour la setosa plt . scatter ( x [ espece == 1 ], y [ espece == 1 ], color = 'r' , label = 'versicolor' ) plt . scatter ( x [ espece == 2 ], y [ espece == 2 ], color = 'b' , label = 'virginica' ) plt . legend () #affichage de la l\u00e9gende plt . show () # affichage du graphique On constate que ces points sont regroup\u00e9s par esp\u00e8ces d'iris. Exercice 1 : Ouvrir l'activit\u00e9 Capytale n\u00b0 : c0d5-1738910 ; Copier/coller le code pr\u00e9c\u00e9dent et ex\u00e9cuter-le. Modifier ce code et observer.","title":"Les donn\u00e9es d'Edgar Anderson relatives aux diff\u00e9rentes esp\u00e8ces d'iris"},{"location":"Premiere/kppv/#comment-apprendre-a-reconnaitre-une-espece-diris","text":"Consid\u00e9rons maintenant une iris dont les p\u00e9tales mesurent 0,5 cm de large et 2 cm de long. Comment d\u00e9terminer l'esp\u00e8ce \u00e0 laquelle cette iris appartient ? Afin de r\u00e9pondre \u00e0 cette probl\u00e9matique, nous allons placer cette nouvelle donn\u00e9e sur le graphique: 1 plt . scatter ( 2.0 , 0.5 , color = \"black\" ) Dans ce cas, on voit clairement qu'il y a de fortes chances pour que l'iris soit de l'esp\u00e8ce \"setosa\". Cependant, il existe des cas o\u00f9 il est beaucoup plus difficile de r\u00e9pondre, par exemple pour une iris dont les p\u00e9tales mesurent 0,75 cm de large et 2,5 cm de long. Afin de d\u00e9terminer si l'iris appartient \u00e0 l'esp\u00e8ce \"s\u00e9tosa\" ou \u00e0 l'esp\u00e8ce \"virginica\", nous allons devoir utiliser l'algorithme des k plus proches voisins. Exercice 2 : R\u00e9aliser sur cette activit\u00e9 capytale le code pour ins\u00e9rer l'iris inconnu.","title":"Comment apprendre \u00e0 reconna\u00eetre une esp\u00e8ce d'iris"},{"location":"Premiere/kppv/#algorithme-des-k-plus-proches-voisins","text":"Quel est le principe de cet algorithme ? On calcule la distance entre le point correspondant \u00e0 l'iris inconnu et chaque point issu du jeu de donn\u00e9es \"iris\" ; On s\u00e9lectionne les k distances les plus petites (les k plus proches voisins) ; Parmi les k plus proches voisins, on d\u00e9termine quelle est l'esp\u00e8ce majoritaire, et on attribue \u00e0 notre iris inconnu cette esp\u00e8ce majoritaire. Prenons k = 3 : Les 3 plus proches voisins sont deux \"setosa\" et un \"virginica\". D'apr\u00e8s l'algorithme des \"k plus proches voisins\", notre iris inconnue appartient \u00e0 l'esp\u00e8ce \"setosa\". La biblioth\u00e8que Python Scikit Learn propose un grand nombre d'algorithmes li\u00e9 au machine learning (c'est sans aucun doute la biblioth\u00e8que la plus utilis\u00e9e en machine learning). Parmi tous ces algorithmes, Scikit Learn propose l'algorithme des k plus proches voisins. Importer la biblioth\u00e8que: 1 from sklearn.neighbors import KNeighborsClassifier Compl\u00e9ter le programme pr\u00e9c\u00e9dent (la fonction plt.show() devra \u00eatre plac\u00e9e en fin de script): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 k = 3 #nbre de plus proches voisins #donn\u00e9es concernant l'iris inconnu longueur = 2 , 5 largeur = 0.75 #algo knn d = list ( zip ( x , y )) #permet de passer des 2 listes x et y (x = [1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, ...] #y = [0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.4,....] \u00e0 une liste de tuples #d = [(1.4, 0.2), (1.4, 0.2), (1.3, 0.2) (1.5, 0.2), (1.4, 0.2), (1.7, 0.2), (1.4, 0.4), ...] model = KNeighborsClassifier ( n_neighbors = k ) #\"KNeighborsClassifier\" est une m\u00e9thode issue #de la biblioth\u00e8que scikit-learn model . fit ( d , espece ) prediction = model . predict ([[ longueur , largeur ]]) #fin algo knn #Affichage r\u00e9sultats txt = \"R\u00e9sultat : \" if prediction [ 0 ] == 0 : txt = txt + \"setosa\" if prediction [ 0 ] == 2 : txt = txt + \"virginica\" if prediction [ 0 ] == 1 : txt = txt + \"versicolor\" plt . text ( 4 , 0.5 , txt , fontsize = 12 ) Exercice 3 : Sur cette activit\u00e9 Capytale, r\u00e9aliser le script afin de d\u00e9terminer l'esp\u00e8ce de l'iris inconnu. Exercice 4 : Le r\u00e9sultat d\u00e9pend-t-il du nombre de voisins ? Pour r\u00e9pondre \u00e0 cette question, relancer le script en prenant toujours le m\u00eame iris inconnu mais en faisant varier le nombre de voisins. Que constatez-vous ?","title":"Algorithme des k plus proches voisins"},{"location":"Premiere/neumann/","text":"Architecture mat\u00e9rielle Les portes logiques # Contexte # Les circuits d\u2019un ordinateur manipulent uniquement des chiffres binaires 0 ou 1 qui sont simplement repr\u00e9sent\u00e9s par des tensions \u00e9lectriques (0 ou +V). On peut r\u00e9aliser des op\u00e9rations sur ces nombres binaires \u00e0 l\u2019aide de circuits logiques qui sont concr\u00e8tement construits \u00e0 partir de transistors. Ces transistors peuvent se comporter comme des interrupteurs \u00e0 la mani\u00e8re de l\u2019exemple suivant. transistor Lorsque la broche B est sous tension (+V), un courant peut s\u2019\u00e9tablir entre E et la masse . Le sens du courant est indiqu\u00e9 par la petite fl\u00e8che. Le transistor peut alors \u00eatre consid\u00e9r\u00e9 comme un interrupteur ferm\u00e9. Inversement, quand B est \u00e0 0 V, la broche E reste sous tension haute et le transistor peut \u00eatre consid\u00e9r\u00e9 comme un interrupteur ouvert. La porte NOT (ou NON) # La porte NOT demande un seul transistor. Elle est la plus simple de toutes les portes. transistor Elle n\u2019a qu\u2019un seul bit en entr\u00e9e (E) et sa sortie (S) vaut 1 quand l\u2019entr\u00e9e vaut 0 et inversement. on peut obtenir ce que l\u2019on appelle la table de v\u00e9rit\u00e9 de la porte \"NOT\" (voir ci-dessous). entr\u00e9e E sortie S \u00d8 1 1 \u00d8 Table de v\u00e9rit\u00e9 de la porte NOT On en d\u00e9duit l'\u00e9quation suivante : \\(S = \\overline{E}\\) Graphiquement, on repr\u00e9sente cette porte comme dans le sch\u00e9ma ci-dessous (notation am\u00e9ricaine). Porte NOT La porte AND (ET) # La table de v\u00e9rit\u00e9 de la porte \"AND\" est repr\u00e9sent\u00e9e ci-dessous. entr\u00e9e A entr\u00e9e B sortie S \u00d8 0 0 0 1 0 1 0 0 1 1 1 Table de v\u00e9rit\u00e9 de la porte AND On peut en d\u00e9duire l'\u00e9quation \\(S =A.B\\) Porte AND On peut illustrer cette fonction de la mani\u00e8re suivante: Une lampe s'allume si l'on appuie sur \u00ab a \u00bb ET \u00ab b \u00bb et seulement dans ce cas l\u00e0. La fonction \u00ab ET \u00bb est caract\u00e9ris\u00e9e par des interrupteurs NO (normalement ouvert) mont\u00e9s en s\u00e9rie. Illustration La porte NAND (NON ET) # La table de v\u00e9rit\u00e9 de la porte \"NAND\" est repr\u00e9sent\u00e9e ci-dessous. entr\u00e9e A entr\u00e9e B sortie S \u00d8 0 1 0 1 1 1 0 1 1 1 0 Table de v\u00e9rit\u00e9 de la porte NAND On peut en d\u00e9duire l'\u00e9quation \\(S = \\overline{A.B}\\) Porte NAND Remarque : Cette porte peut \u00eatre r\u00e9alis\u00e9e de la mani\u00e8re suivante: Circuit porte NAND Porte OR (OU) # La table de v\u00e9rit\u00e9 de la porte \"OR\" est repr\u00e9sent\u00e9e ci-dessous. entr\u00e9e A entr\u00e9e B sortie S \u00d8 0 0 0 1 1 1 0 1 1 1 1 Table de v\u00e9rit\u00e9 de la porte OR On peut en d\u00e9duire l'\u00e9quation \\(S = A + B \\) Porte OR Porte NOR (NON OU) # La table de v\u00e9rit\u00e9 de la porte \"NOR\" est repr\u00e9sent\u00e9e ci-dessous. entr\u00e9e A entr\u00e9e B sortie S \u00d8 0 1 0 1 0 1 0 0 1 1 0 Table de v\u00e9rit\u00e9 de la porte NOR On peut en d\u00e9duire l'\u00e9quation \\( S = \\overline{A + B} \\) Porte OR Remarque : Cette porte peut \u00eatre r\u00e9alis\u00e9e de la mani\u00e8re suivante: Circuit porte NOR La porte XOR (OU EXCLUSIF) # La table de v\u00e9rit\u00e9 de la porte \"XOR\" est repr\u00e9sent\u00e9e ci-dessous. entr\u00e9e A entr\u00e9e B sortie S \u00d8 0 0 0 1 1 1 0 1 1 1 0 Table de v\u00e9rit\u00e9 de la porte XOR Porte XOR Une application des portes logiques : les masques de sous-r\u00e9seau # Dans un r\u00e9seau TCP/IP, un ordinateur a une adresse IP qui l\u2019identifie de mani\u00e8re unique (comme un num\u00e9ro de t\u00e9l\u00e9phone), ainsi qu\u2019un masque de sous-r\u00e9seau. L\u2019adresse IP et le masque de sous-r\u00e9seau sont des groupes de 4 entiers positifs, cod\u00e9s tous les deux sur 4 octets. Le masque identifie \u00e0 quel sous r\u00e9seau d\u2019Internet il fait partie, et permet d\u2019obtenir l\u2019adresse IP du sous-r\u00e9seau \u00e0 l\u2019aide d\u2019une op\u00e9ration bool\u00e9enne. Exemple : un ordinateur a pour adresse IP 192.168.0.42 et son masque de sous-r\u00e9seau est 255.255.255.0. IP 11000000101010000000000000101010 Masque 11111111111111111111111100000000 AND 11000000101010000000000000000000 Adresse du sous-r\u00e9seau Porte XOR Pour obtenir l\u2019adresse du sous-r\u00e9seau de l\u2019ordinateur, on effectue alors un AND entre les octets de l\u2019adresse IP et les octets du masque. En repr\u00e9sentation binaire, cela donne : Sur un processeur 32 bits, le AND est une op\u00e9ration primitive du processeur, donc l\u2019op\u00e9ration de d\u00e9ter- mination du sous-masque r\u00e9seau se fait en une op\u00e9ration. Des portes logiques \u00e0 l\u2019ordinateur # Circuit combinatoire et circuit s\u00e9quentiel # D\u2019une mani\u00e8re g\u00e9n\u00e9rale, les circuits \u00e9lectroniques poss\u00e8dent plusieurs entr\u00e9es et plusieurs sorties. Quand les sorties d\u00e9pendent directement et uniquement des entr\u00e9es, on parle de cicuits combinatoires. Il existe d\u2019autres types de circuit qui s\u2019appellent circuits s\u00e9quentiels. Les sorties de ces circuits d\u00e9pendent d\u2019un \u00e9tat ant\u00e9rieur du circuit. C\u2019est ce type de circuit qu\u2019on utilise pour r\u00e9aliser des m\u00e9moires (RAM, registres,etc...). Un exemple de circuit combinatoire logique : l\u2019additionneur # En combinant les portes logiques, on obtient des circuits plus complexes. Par exemple en combinant 2 portes \"OU EXCLUSIF\", 2 portes \"ET\" et une porte \"OU\" on obtient un additionneur repr\u00e9sent\u00e9 ci-dessous. Additionneur Comme son nom l\u2019indique, l\u2019additionneur permet d\u2019additionner 2 bits (E1 et E2) en tenant compte de la retenue entrante (\"Cin\" \"carry in\" en anglais). En sortie on obtient le r\u00e9sultat de l\u2019addition (S) et la retenue sortante (\"Cout\"). Les m\u00e9moires # On stocke l\u2019information \u00e0 l\u2019aide de circuit dit de type \"bascule\". Ce circuit est une combinaison de plusieurs portes logiques. Il n\u2019est pas question pour nous d\u2019\u00e9tudier ce type de circuit, le sch\u00e9ma ci-dessus vous permet juste de v\u00e9rifier qu\u2019une fois de plus nous avons bien \u00e0 faire \u00e0 une combinaison de porte logique. M\u00e9moire Le mod\u00e8le de von Neumann # Le principe # John Von Neumann (1903-1957) est un ing\u00e9nieur, math\u00e9maticien et physicien am\u00e9ricano-hongrois.Il a particip\u00e9 au projet Manhattan (premi\u00e8re bombe atomique) et \u00e0 l'ENIAC. Son nom reste attach\u00e9 \u00e0 un mod\u00e8le qu'il propose en 1944, mod\u00e8le d'architecture novateur qui sert toujours de base \u00e0 nos architectures actuelles. Le mod\u00e8le de von Neumann pr\u00e9cise les 4 composants essentiels ainsi que les interactions entre ces diff\u00e9rents composants. Ces composants sont les suivants : l'unit\u00e9 de commande dont le r\u00f4le est de : lire le programme ; d\u00e9coder les instructions ; commander l'ex\u00e9cution. l'unit\u00e9 arithm\u00e9tique et logique (UAL ou ALU en anglais) : son r\u00f4le est d\u2019effectuer les op\u00e9rations de base ; la m\u00e9moire : qui contient \u00e0 la fois les donn\u00e9es \u00e0 traiter et les instructions du programme. Cette id\u00e9e de stocker au m\u00eame endroit donn\u00e9es et programme est l'id\u00e9e centrale de l'architecture von Neumann ; les dispositifs d\u2019entr\u00e9e-sortie, qui permettent de communiquer avec le monde ext\u00e9rieur.. Les diff\u00e9rents \u00e9l\u00e9ments \u00e9changent des informations \u00e0 l\u2019aide de bus. Mod\u00e8le de Von Neumann L'horloge est le cadenceur qui organise l'accomplissement des instructions, et dont l'unit\u00e9 est appel\u00e9 cycle d'horloge (1 cycle = 1 instuction). Les deux premi\u00e8res parties sont habituellement rassembl\u00e9es dans un ensemble de circuits \u00e9lectroniques qu\u2019on appelle Unit\u00e9 Centrale de Traitement ou plus simplement processeur (ou CPU pour Centrale Processing Unit). Physiquement, un syst\u00e8me informatique est constitu\u00e9 de plusieurs \u00e9l\u00e9ments : une machine, c\u2019est-\u00e0-dire un bo\u00eetier contenant une carte m\u00e8re avec un microprocesseur, des barrettes de m\u00e9moire vive, une carte graphique une carte r\u00e9seau, des ports de communication et des p\u00e9riph\u00e9riques. Principaux composants du mod\u00e8le de Neumann # Unit\u00e9 de contr\u00f4le # Cette unit\u00e9 joue le r\u00f4le de chef d\u2019orchestre de l\u2019ordinateur. C\u2019est ce composant qui est charg\u00e9 r\u00e9cup\u00e9rer en m\u00e9moire la prochaine instruction \u00e0 ex\u00e9cuter et les donn\u00e9es sur lesquelles elle doit op\u00e9rer puis les envoie \u00e0 l\u2019UAL. M\u00e9moires # La m\u00e9moire de l\u2019ordinateur contient \u00e0 la fois les programmes et les donn\u00e9es. On distingue habituellement deux types de m\u00e9moires : la m\u00e9moire vive ou volatile est celle qui perd son contenu d\u00e8s que l\u2019ordinateur est \u00e9teint. Les donn\u00e9es stock\u00e9es dans la m\u00e9moire vive peuvent \u00eatre lues, effac\u00e9es ou d\u00e9plac\u00e9es comme on le souhaite. Le principal avantage de cette m\u00e9moire est la rapidit\u00e9 d\u2019acc\u00e8s aux donn\u00e9es. On parle souvent de m\u00e9moire RAM (pour l\u2019anglais Random Acces Memory ). Les ordinateurs actuels disposent en g\u00e9n\u00e9ral de 8 ou 16 Go de RAM. la m\u00e9moire non-volatile est celle qui conserve ses donn\u00e9es quand on coupe l\u2019alimentation \u00e9lectrique de l\u2019ordinateur. Il existe plusieurs types de telles m\u00e9moires. Par exemple, la ROM (pour Read-only Memory) est une m\u00e9moire non modifiable qui contient habituellement des donn\u00e9es n\u00e9cessaires au d\u00e9marrage de l\u2019ordinateur ou tout autre information dont l\u2019ordinateur a besoin pour fonctionner. La m\u00e9moire Flash est autre exemple de m\u00e9moire non volatile. Contrairement \u00e0 la ROM, cette m\u00e9moire est modifiable. Contrairement \u00e0 la RAM, ces m\u00e9moires sont souvent beaucoup plus lentes. Assembleur # Le simulateur # On trouve en ligne un simulateur . Remarque : ne pas l\u2019ouvrir avec Firefox car dans ce navigateur, les instructions ne s\u2019affichent pas correctement dans la RAM. simulateur Il se d\u00e9compose ainsi : Une m\u00e9moire vive (\u00e0 droite) dont chaque case m\u00e9moire (cellule) comporte 32 bits . Chaque cellule de la m\u00e9moire poss\u00e8de une adresse (de 000 \u00e0 199), ces adresses sont cod\u00e9es en base 10 (vous pouvez vous en assurer en cliquant sur OPTION puis binary). Un \u00e9diteur (\u00e0 gauche) pour taper le programme en assembleur ; Le processeur (au centre) constitu\u00e9 principalement de l\u2019Unit\u00e9 de Contr\u00f4le, de l\u2019Unit\u00e9 Arithm\u00e9tique et Logique et des registres de R0 \u00e0 R12 plus un compteur de programme (PC pour Program counter) qui contient en permanence l\u2019adresse de la prochaine instruction \u00e0 ex\u00e9cuter. Les instructions # Chaque processeur poss\u00e8de son propre jeu d'instruction. Pour celui propos\u00e9, les instructions sont disponibles sur cette page . Voici les principales instructions traduites : LDR Rd, < adresse m\u00e9moire > : charge la valeur enregistr\u00e9e dans l' < adresse m\u00e9moire >** dans le registe d STR Rd, < adresse m\u00e9moire > : enregistre la valeur du registre d dans la m\u00e9moire sp\u00e9cifi\u00e9e par < adresse m\u00e9moire > ADD Rd, Rn, < operand2 > : ajoute la valeur sp\u00e9cifi\u00e9e par < operand2 > \u00e0 la valeur du registre n et enregistre le r\u00e9sultat dans le registre d SUB Rd, Rn, < operand2 > : soustrait la valeur de < operand2 > \u00e0 la valeur du registre n et enregistre le r\u00e9sultat dans le registre d MOV Rd, < operand2 > : copie la valeur < operand2 > dans le registre d CMP Rn, < operand2 > : compare la valeur de registre n avec la valeur de < operand2 >. B < label > : branchement inconditionnel jusqu'\u00e0 la positon < label > dans le programme. B < condition > < label > : branchement conditionnel vers la position < label > dans le programme si la derni\u00e8re comparaison rempli le crit\u00e8re sp\u00e9cifi\u00e9 par < condition >. Les valeurs possibles sont : EQ:\u00e9gal \u00e0 ; NE: n'est pas \u00e9gal \u00e0; GT:Plus grand que; LT: Moins grand que. AND Rd, Rn, < operand2 > : effectue l'op\u00e9ration bit \u00e0 bit logique AND (ET) entre la valeur du registre n et la valeur < operand2 > et enregistre le r\u00e9sultat dans le registre d. ORR Rd, Rn, < operand2 > effectue l'op\u00e9ration bit \u00e0 bit logique OR (OU) entre la valeur du registre n et la valeur < operand2 > et enregistre le r\u00e9sultat dans le registre d. EOR Rd, Rn, < operand2 > : effectue l'op\u00e9ration bit \u00e0 bit logique XOR(OU exclusif) entre la valeur du registre n et la valeur < operand2 > et enregistre le r\u00e9sultat dans le registre d. MVN Rd, < operand2 > : effectue l'op\u00e9ration bit \u00e0 bit logique NOT (NON) sur la valeur < operand2 > et enregistre le r\u00e9sultat dans le registre d. LSL Rd, Rn, < operand2 > : d\u00e9cale de < operand2 > bit(s) vers la gauche la valeur du registre n et enregistre le r\u00e9sultat dans le registre d LSR Rd, Rn, < operand2 > : d\u00e9cale de < operand2 > bit(s) vers la droite la valeur du registre n et enregistre le r\u00e9sultat dans le registre d HALT Arr\u00eate l'execution du programme. < operand2 > peut \u00eatre #nnn (c'est \u00e0 dire un nombre, exemple #42) ou bien Rm (c'est \u00e0 dire le registre m , par exemple R1 est le registre num\u00e9ro 1) Les registres vont de R0 \u00e0 R12. Compl\u00e9ments data, INP et OUT : la pseudo instruction DAT vous permet de mettre un nombre dans la m\u00e9moire en utilisant l'assembleur. Un label peut aussi \u00eatre pris comme donn\u00e9e. INP Rd,2 : lis un nombre dans le registre d. OUT Rd,4 : retourne en sortie le nombre du registre d. Pour OUT, vous pouvez retourner des nombres sign\u00e9s (positifs ou n\u00e9gatifs \\(\\rightarrow\\) param\u00e8tre 4), des nombres non sign\u00e9s (que positifs \\(\\rightarrow\\) param\u00e8tre 5), des hexad\u00e9cimaux (param\u00e8tre 6) ou des charact\u00e8res (param\u00e8tre 7). Vous pouvez entrer des hexa comme 0xnnn partout o\u00f9 un nombre est attendu. Exemples et exercices # Exemple 1 # MOV R0,#42 STR R0,150 HALT Interpr\u00e9tation : On place dans le registre R0 du processeur la valeur 42 ; On place le contenu du registre R0 (\u00e0 savoir 42) dans la m\u00e9moire vive \u00e0 la place 150 ; On stoppe le programme ; Taper ce programme dans l\u2019\u00e9diteur du simulateur, et le faire fonctionner. Observer. Exercices # Exercice : \u00c0 l\u2019aide des instructions d\u00e9crites dans le chapitre pr\u00e9c\u00e9dent, dites ce que fait ce programme suivant ligne par ligne, puis l\u2019ex\u00e9cuter. V\u00e9rifier ce que vous aviez trouv\u00e9. MOV R0,#42 MOV R1,#45 ADD R0,R0,R1 OUT R0,4 HALT Exercice : \u00c9crire un programme qui effectue une soustraction entre 95 et 52, l\u2019enregistre en m\u00e9moire (\u00e0 la place 143) et qui affiche le r\u00e9sultat dans la console Output. Le taper et l\u2019ex\u00e9cuter. Exemple 2 # Cet exemple s\u2019affiche quand on clique sur SELECT puis max dans le simulateur. INP R0,2 INP R1,2 CMP R1,R0 BGT HIGHER OUT R0,4 B DONE HIGHER: OUT R1,4 DONE: HALT Interpr\u00e9tation : On place deux nombres dans les registres R0 et R1 gr\u00e2ce \u00e0 la fonction INP ; On compare le contenu du registre R1 au contenu du registre R0 ; Si le contenu de R1 est plus grand que celui de R0, on effectue un branchement jusqu\u2019au label HIGHER et on affiche le contenu de R1 ; Sinon, on affiche le contenu de R0 ; On effectue le branchement conditionnel vers done qui stoppe le programme. Exercice : R\u00e9aliser un programme qui prend deux nombres et qui retourne le plus petit. Exercice : Traduire le programme python ci-dessous en assembleur x = 0 // on met en memoire dans la variable nomme x la valeur 0 while x < 3 : x = x + 1 print ( x ) L\u2019assembleur et le python # En python aussi, on peut avoir une id\u00e9e de ce qui est traduit en langage machine gr\u00e2ce \u00e0 la biblioth\u00e8que dis comme dans l\u2019exemple suivant. Taper l\u2019exemple suivant dans un \u00e9diteur Python et observer. import dis dis . dis ( \u2019 x = 1 ; x = x + 1 \u2019 ) Exercice : Traduire en assembleur AQA (celui que nous avons vu) le langage d\u2019assemblage issu du python. Bibliographie # Le site de David Roche Le site des enseignants du lyc\u00e9e Blaise Pascal \u00e0 Saint-Dizier Le simulateur ainsi que la documentation en anglais Le site du Yeti Le livre Num\u00e9rique et Sciences Informatiques aux \u00e9ditions ellipses de Thibaut Balabonski, Sylvain Conchon, Jean-Christophe Filli\u00e2tre et Kim Nguyen. C C++ #include <stdio.h> int main ( void ) { printf ( \"Hello world! \\n \" ); return 0 ; } #include <iostream> int main ( void ) { std :: cout << \"Hello world!\" << std :: endl ; return 0 ; }","title":"Neuildumann"},{"location":"Premiere/neumann/#les-portes-logiques","text":"","title":"Les portes logiques"},{"location":"Premiere/neumann/#contexte","text":"Les circuits d\u2019un ordinateur manipulent uniquement des chiffres binaires 0 ou 1 qui sont simplement repr\u00e9sent\u00e9s par des tensions \u00e9lectriques (0 ou +V). On peut r\u00e9aliser des op\u00e9rations sur ces nombres binaires \u00e0 l\u2019aide de circuits logiques qui sont concr\u00e8tement construits \u00e0 partir de transistors. Ces transistors peuvent se comporter comme des interrupteurs \u00e0 la mani\u00e8re de l\u2019exemple suivant. transistor Lorsque la broche B est sous tension (+V), un courant peut s\u2019\u00e9tablir entre E et la masse . Le sens du courant est indiqu\u00e9 par la petite fl\u00e8che. Le transistor peut alors \u00eatre consid\u00e9r\u00e9 comme un interrupteur ferm\u00e9. Inversement, quand B est \u00e0 0 V, la broche E reste sous tension haute et le transistor peut \u00eatre consid\u00e9r\u00e9 comme un interrupteur ouvert.","title":"Contexte"},{"location":"Premiere/neumann/#la-porte-not-ou-non","text":"La porte NOT demande un seul transistor. Elle est la plus simple de toutes les portes. transistor Elle n\u2019a qu\u2019un seul bit en entr\u00e9e (E) et sa sortie (S) vaut 1 quand l\u2019entr\u00e9e vaut 0 et inversement. on peut obtenir ce que l\u2019on appelle la table de v\u00e9rit\u00e9 de la porte \"NOT\" (voir ci-dessous). entr\u00e9e E sortie S \u00d8 1 1 \u00d8 Table de v\u00e9rit\u00e9 de la porte NOT On en d\u00e9duit l'\u00e9quation suivante : \\(S = \\overline{E}\\) Graphiquement, on repr\u00e9sente cette porte comme dans le sch\u00e9ma ci-dessous (notation am\u00e9ricaine). Porte NOT","title":"La porte NOT (ou NON)"},{"location":"Premiere/neumann/#la-porte-and-et","text":"La table de v\u00e9rit\u00e9 de la porte \"AND\" est repr\u00e9sent\u00e9e ci-dessous. entr\u00e9e A entr\u00e9e B sortie S \u00d8 0 0 0 1 0 1 0 0 1 1 1 Table de v\u00e9rit\u00e9 de la porte AND On peut en d\u00e9duire l'\u00e9quation \\(S =A.B\\) Porte AND On peut illustrer cette fonction de la mani\u00e8re suivante: Une lampe s'allume si l'on appuie sur \u00ab a \u00bb ET \u00ab b \u00bb et seulement dans ce cas l\u00e0. La fonction \u00ab ET \u00bb est caract\u00e9ris\u00e9e par des interrupteurs NO (normalement ouvert) mont\u00e9s en s\u00e9rie. Illustration","title":"La porte AND (ET)"},{"location":"Premiere/neumann/#la-porte-nand-non-et","text":"La table de v\u00e9rit\u00e9 de la porte \"NAND\" est repr\u00e9sent\u00e9e ci-dessous. entr\u00e9e A entr\u00e9e B sortie S \u00d8 0 1 0 1 1 1 0 1 1 1 0 Table de v\u00e9rit\u00e9 de la porte NAND On peut en d\u00e9duire l'\u00e9quation \\(S = \\overline{A.B}\\) Porte NAND Remarque : Cette porte peut \u00eatre r\u00e9alis\u00e9e de la mani\u00e8re suivante: Circuit porte NAND","title":"La porte NAND (NON ET)"},{"location":"Premiere/neumann/#porte-or-ou","text":"La table de v\u00e9rit\u00e9 de la porte \"OR\" est repr\u00e9sent\u00e9e ci-dessous. entr\u00e9e A entr\u00e9e B sortie S \u00d8 0 0 0 1 1 1 0 1 1 1 1 Table de v\u00e9rit\u00e9 de la porte OR On peut en d\u00e9duire l'\u00e9quation \\(S = A + B \\) Porte OR","title":"Porte OR (OU)"},{"location":"Premiere/neumann/#porte-nor-non-ou","text":"La table de v\u00e9rit\u00e9 de la porte \"NOR\" est repr\u00e9sent\u00e9e ci-dessous. entr\u00e9e A entr\u00e9e B sortie S \u00d8 0 1 0 1 0 1 0 0 1 1 0 Table de v\u00e9rit\u00e9 de la porte NOR On peut en d\u00e9duire l'\u00e9quation \\( S = \\overline{A + B} \\) Porte OR Remarque : Cette porte peut \u00eatre r\u00e9alis\u00e9e de la mani\u00e8re suivante: Circuit porte NOR","title":"Porte NOR (NON OU)"},{"location":"Premiere/neumann/#la-porte-xor-ou-exclusif","text":"La table de v\u00e9rit\u00e9 de la porte \"XOR\" est repr\u00e9sent\u00e9e ci-dessous. entr\u00e9e A entr\u00e9e B sortie S \u00d8 0 0 0 1 1 1 0 1 1 1 0 Table de v\u00e9rit\u00e9 de la porte XOR Porte XOR","title":"La porte XOR (OU EXCLUSIF)"},{"location":"Premiere/neumann/#une-application-des-portes-logiques-les-masques-de-sous-reseau","text":"Dans un r\u00e9seau TCP/IP, un ordinateur a une adresse IP qui l\u2019identifie de mani\u00e8re unique (comme un num\u00e9ro de t\u00e9l\u00e9phone), ainsi qu\u2019un masque de sous-r\u00e9seau. L\u2019adresse IP et le masque de sous-r\u00e9seau sont des groupes de 4 entiers positifs, cod\u00e9s tous les deux sur 4 octets. Le masque identifie \u00e0 quel sous r\u00e9seau d\u2019Internet il fait partie, et permet d\u2019obtenir l\u2019adresse IP du sous-r\u00e9seau \u00e0 l\u2019aide d\u2019une op\u00e9ration bool\u00e9enne. Exemple : un ordinateur a pour adresse IP 192.168.0.42 et son masque de sous-r\u00e9seau est 255.255.255.0. IP 11000000101010000000000000101010 Masque 11111111111111111111111100000000 AND 11000000101010000000000000000000 Adresse du sous-r\u00e9seau Porte XOR Pour obtenir l\u2019adresse du sous-r\u00e9seau de l\u2019ordinateur, on effectue alors un AND entre les octets de l\u2019adresse IP et les octets du masque. En repr\u00e9sentation binaire, cela donne : Sur un processeur 32 bits, le AND est une op\u00e9ration primitive du processeur, donc l\u2019op\u00e9ration de d\u00e9ter- mination du sous-masque r\u00e9seau se fait en une op\u00e9ration.","title":"Une application des portes logiques : les masques de sous-r\u00e9seau"},{"location":"Premiere/neumann/#des-portes-logiques-a-lordinateur","text":"","title":"Des portes logiques \u00e0 l\u2019ordinateur"},{"location":"Premiere/neumann/#circuit-combinatoire-et-circuit-sequentiel","text":"D\u2019une mani\u00e8re g\u00e9n\u00e9rale, les circuits \u00e9lectroniques poss\u00e8dent plusieurs entr\u00e9es et plusieurs sorties. Quand les sorties d\u00e9pendent directement et uniquement des entr\u00e9es, on parle de cicuits combinatoires. Il existe d\u2019autres types de circuit qui s\u2019appellent circuits s\u00e9quentiels. Les sorties de ces circuits d\u00e9pendent d\u2019un \u00e9tat ant\u00e9rieur du circuit. C\u2019est ce type de circuit qu\u2019on utilise pour r\u00e9aliser des m\u00e9moires (RAM, registres,etc...).","title":"Circuit combinatoire et circuit s\u00e9quentiel"},{"location":"Premiere/neumann/#un-exemple-de-circuit-combinatoire-logique-ladditionneur","text":"En combinant les portes logiques, on obtient des circuits plus complexes. Par exemple en combinant 2 portes \"OU EXCLUSIF\", 2 portes \"ET\" et une porte \"OU\" on obtient un additionneur repr\u00e9sent\u00e9 ci-dessous. Additionneur Comme son nom l\u2019indique, l\u2019additionneur permet d\u2019additionner 2 bits (E1 et E2) en tenant compte de la retenue entrante (\"Cin\" \"carry in\" en anglais). En sortie on obtient le r\u00e9sultat de l\u2019addition (S) et la retenue sortante (\"Cout\").","title":"Un exemple de circuit combinatoire logique : l\u2019additionneur"},{"location":"Premiere/neumann/#les-memoires","text":"On stocke l\u2019information \u00e0 l\u2019aide de circuit dit de type \"bascule\". Ce circuit est une combinaison de plusieurs portes logiques. Il n\u2019est pas question pour nous d\u2019\u00e9tudier ce type de circuit, le sch\u00e9ma ci-dessus vous permet juste de v\u00e9rifier qu\u2019une fois de plus nous avons bien \u00e0 faire \u00e0 une combinaison de porte logique. M\u00e9moire","title":"Les m\u00e9moires"},{"location":"Premiere/neumann/#le-modele-de-von-neumann","text":"","title":"Le mod\u00e8le de von Neumann"},{"location":"Premiere/neumann/#le-principe","text":"John Von Neumann (1903-1957) est un ing\u00e9nieur, math\u00e9maticien et physicien am\u00e9ricano-hongrois.Il a particip\u00e9 au projet Manhattan (premi\u00e8re bombe atomique) et \u00e0 l'ENIAC. Son nom reste attach\u00e9 \u00e0 un mod\u00e8le qu'il propose en 1944, mod\u00e8le d'architecture novateur qui sert toujours de base \u00e0 nos architectures actuelles. Le mod\u00e8le de von Neumann pr\u00e9cise les 4 composants essentiels ainsi que les interactions entre ces diff\u00e9rents composants. Ces composants sont les suivants : l'unit\u00e9 de commande dont le r\u00f4le est de : lire le programme ; d\u00e9coder les instructions ; commander l'ex\u00e9cution. l'unit\u00e9 arithm\u00e9tique et logique (UAL ou ALU en anglais) : son r\u00f4le est d\u2019effectuer les op\u00e9rations de base ; la m\u00e9moire : qui contient \u00e0 la fois les donn\u00e9es \u00e0 traiter et les instructions du programme. Cette id\u00e9e de stocker au m\u00eame endroit donn\u00e9es et programme est l'id\u00e9e centrale de l'architecture von Neumann ; les dispositifs d\u2019entr\u00e9e-sortie, qui permettent de communiquer avec le monde ext\u00e9rieur.. Les diff\u00e9rents \u00e9l\u00e9ments \u00e9changent des informations \u00e0 l\u2019aide de bus. Mod\u00e8le de Von Neumann L'horloge est le cadenceur qui organise l'accomplissement des instructions, et dont l'unit\u00e9 est appel\u00e9 cycle d'horloge (1 cycle = 1 instuction). Les deux premi\u00e8res parties sont habituellement rassembl\u00e9es dans un ensemble de circuits \u00e9lectroniques qu\u2019on appelle Unit\u00e9 Centrale de Traitement ou plus simplement processeur (ou CPU pour Centrale Processing Unit). Physiquement, un syst\u00e8me informatique est constitu\u00e9 de plusieurs \u00e9l\u00e9ments : une machine, c\u2019est-\u00e0-dire un bo\u00eetier contenant une carte m\u00e8re avec un microprocesseur, des barrettes de m\u00e9moire vive, une carte graphique une carte r\u00e9seau, des ports de communication et des p\u00e9riph\u00e9riques.","title":"Le principe"},{"location":"Premiere/neumann/#principaux-composants-du-modele-de-neumann","text":"","title":"Principaux composants du mod\u00e8le de Neumann"},{"location":"Premiere/neumann/#unite-de-controle","text":"Cette unit\u00e9 joue le r\u00f4le de chef d\u2019orchestre de l\u2019ordinateur. C\u2019est ce composant qui est charg\u00e9 r\u00e9cup\u00e9rer en m\u00e9moire la prochaine instruction \u00e0 ex\u00e9cuter et les donn\u00e9es sur lesquelles elle doit op\u00e9rer puis les envoie \u00e0 l\u2019UAL.","title":"Unit\u00e9 de contr\u00f4le"},{"location":"Premiere/neumann/#memoires","text":"La m\u00e9moire de l\u2019ordinateur contient \u00e0 la fois les programmes et les donn\u00e9es. On distingue habituellement deux types de m\u00e9moires : la m\u00e9moire vive ou volatile est celle qui perd son contenu d\u00e8s que l\u2019ordinateur est \u00e9teint. Les donn\u00e9es stock\u00e9es dans la m\u00e9moire vive peuvent \u00eatre lues, effac\u00e9es ou d\u00e9plac\u00e9es comme on le souhaite. Le principal avantage de cette m\u00e9moire est la rapidit\u00e9 d\u2019acc\u00e8s aux donn\u00e9es. On parle souvent de m\u00e9moire RAM (pour l\u2019anglais Random Acces Memory ). Les ordinateurs actuels disposent en g\u00e9n\u00e9ral de 8 ou 16 Go de RAM. la m\u00e9moire non-volatile est celle qui conserve ses donn\u00e9es quand on coupe l\u2019alimentation \u00e9lectrique de l\u2019ordinateur. Il existe plusieurs types de telles m\u00e9moires. Par exemple, la ROM (pour Read-only Memory) est une m\u00e9moire non modifiable qui contient habituellement des donn\u00e9es n\u00e9cessaires au d\u00e9marrage de l\u2019ordinateur ou tout autre information dont l\u2019ordinateur a besoin pour fonctionner. La m\u00e9moire Flash est autre exemple de m\u00e9moire non volatile. Contrairement \u00e0 la ROM, cette m\u00e9moire est modifiable. Contrairement \u00e0 la RAM, ces m\u00e9moires sont souvent beaucoup plus lentes.","title":"M\u00e9moires"},{"location":"Premiere/neumann/#assembleur","text":"","title":"Assembleur"},{"location":"Premiere/neumann/#le-simulateur","text":"On trouve en ligne un simulateur . Remarque : ne pas l\u2019ouvrir avec Firefox car dans ce navigateur, les instructions ne s\u2019affichent pas correctement dans la RAM. simulateur Il se d\u00e9compose ainsi : Une m\u00e9moire vive (\u00e0 droite) dont chaque case m\u00e9moire (cellule) comporte 32 bits . Chaque cellule de la m\u00e9moire poss\u00e8de une adresse (de 000 \u00e0 199), ces adresses sont cod\u00e9es en base 10 (vous pouvez vous en assurer en cliquant sur OPTION puis binary). Un \u00e9diteur (\u00e0 gauche) pour taper le programme en assembleur ; Le processeur (au centre) constitu\u00e9 principalement de l\u2019Unit\u00e9 de Contr\u00f4le, de l\u2019Unit\u00e9 Arithm\u00e9tique et Logique et des registres de R0 \u00e0 R12 plus un compteur de programme (PC pour Program counter) qui contient en permanence l\u2019adresse de la prochaine instruction \u00e0 ex\u00e9cuter.","title":"Le simulateur"},{"location":"Premiere/neumann/#les-instructions","text":"Chaque processeur poss\u00e8de son propre jeu d'instruction. Pour celui propos\u00e9, les instructions sont disponibles sur cette page . Voici les principales instructions traduites : LDR Rd, < adresse m\u00e9moire > : charge la valeur enregistr\u00e9e dans l' < adresse m\u00e9moire >** dans le registe d STR Rd, < adresse m\u00e9moire > : enregistre la valeur du registre d dans la m\u00e9moire sp\u00e9cifi\u00e9e par < adresse m\u00e9moire > ADD Rd, Rn, < operand2 > : ajoute la valeur sp\u00e9cifi\u00e9e par < operand2 > \u00e0 la valeur du registre n et enregistre le r\u00e9sultat dans le registre d SUB Rd, Rn, < operand2 > : soustrait la valeur de < operand2 > \u00e0 la valeur du registre n et enregistre le r\u00e9sultat dans le registre d MOV Rd, < operand2 > : copie la valeur < operand2 > dans le registre d CMP Rn, < operand2 > : compare la valeur de registre n avec la valeur de < operand2 >. B < label > : branchement inconditionnel jusqu'\u00e0 la positon < label > dans le programme. B < condition > < label > : branchement conditionnel vers la position < label > dans le programme si la derni\u00e8re comparaison rempli le crit\u00e8re sp\u00e9cifi\u00e9 par < condition >. Les valeurs possibles sont : EQ:\u00e9gal \u00e0 ; NE: n'est pas \u00e9gal \u00e0; GT:Plus grand que; LT: Moins grand que. AND Rd, Rn, < operand2 > : effectue l'op\u00e9ration bit \u00e0 bit logique AND (ET) entre la valeur du registre n et la valeur < operand2 > et enregistre le r\u00e9sultat dans le registre d. ORR Rd, Rn, < operand2 > effectue l'op\u00e9ration bit \u00e0 bit logique OR (OU) entre la valeur du registre n et la valeur < operand2 > et enregistre le r\u00e9sultat dans le registre d. EOR Rd, Rn, < operand2 > : effectue l'op\u00e9ration bit \u00e0 bit logique XOR(OU exclusif) entre la valeur du registre n et la valeur < operand2 > et enregistre le r\u00e9sultat dans le registre d. MVN Rd, < operand2 > : effectue l'op\u00e9ration bit \u00e0 bit logique NOT (NON) sur la valeur < operand2 > et enregistre le r\u00e9sultat dans le registre d. LSL Rd, Rn, < operand2 > : d\u00e9cale de < operand2 > bit(s) vers la gauche la valeur du registre n et enregistre le r\u00e9sultat dans le registre d LSR Rd, Rn, < operand2 > : d\u00e9cale de < operand2 > bit(s) vers la droite la valeur du registre n et enregistre le r\u00e9sultat dans le registre d HALT Arr\u00eate l'execution du programme. < operand2 > peut \u00eatre #nnn (c'est \u00e0 dire un nombre, exemple #42) ou bien Rm (c'est \u00e0 dire le registre m , par exemple R1 est le registre num\u00e9ro 1) Les registres vont de R0 \u00e0 R12. Compl\u00e9ments data, INP et OUT : la pseudo instruction DAT vous permet de mettre un nombre dans la m\u00e9moire en utilisant l'assembleur. Un label peut aussi \u00eatre pris comme donn\u00e9e. INP Rd,2 : lis un nombre dans le registre d. OUT Rd,4 : retourne en sortie le nombre du registre d. Pour OUT, vous pouvez retourner des nombres sign\u00e9s (positifs ou n\u00e9gatifs \\(\\rightarrow\\) param\u00e8tre 4), des nombres non sign\u00e9s (que positifs \\(\\rightarrow\\) param\u00e8tre 5), des hexad\u00e9cimaux (param\u00e8tre 6) ou des charact\u00e8res (param\u00e8tre 7). Vous pouvez entrer des hexa comme 0xnnn partout o\u00f9 un nombre est attendu.","title":"Les instructions"},{"location":"Premiere/neumann/#exemples-et-exercices","text":"","title":"Exemples et exercices"},{"location":"Premiere/neumann/#exemple-1","text":"MOV R0,#42 STR R0,150 HALT Interpr\u00e9tation : On place dans le registre R0 du processeur la valeur 42 ; On place le contenu du registre R0 (\u00e0 savoir 42) dans la m\u00e9moire vive \u00e0 la place 150 ; On stoppe le programme ; Taper ce programme dans l\u2019\u00e9diteur du simulateur, et le faire fonctionner. Observer.","title":"Exemple 1"},{"location":"Premiere/neumann/#exercices","text":"Exercice : \u00c0 l\u2019aide des instructions d\u00e9crites dans le chapitre pr\u00e9c\u00e9dent, dites ce que fait ce programme suivant ligne par ligne, puis l\u2019ex\u00e9cuter. V\u00e9rifier ce que vous aviez trouv\u00e9. MOV R0,#42 MOV R1,#45 ADD R0,R0,R1 OUT R0,4 HALT Exercice : \u00c9crire un programme qui effectue une soustraction entre 95 et 52, l\u2019enregistre en m\u00e9moire (\u00e0 la place 143) et qui affiche le r\u00e9sultat dans la console Output. Le taper et l\u2019ex\u00e9cuter.","title":"Exercices"},{"location":"Premiere/neumann/#exemple-2","text":"Cet exemple s\u2019affiche quand on clique sur SELECT puis max dans le simulateur. INP R0,2 INP R1,2 CMP R1,R0 BGT HIGHER OUT R0,4 B DONE HIGHER: OUT R1,4 DONE: HALT Interpr\u00e9tation : On place deux nombres dans les registres R0 et R1 gr\u00e2ce \u00e0 la fonction INP ; On compare le contenu du registre R1 au contenu du registre R0 ; Si le contenu de R1 est plus grand que celui de R0, on effectue un branchement jusqu\u2019au label HIGHER et on affiche le contenu de R1 ; Sinon, on affiche le contenu de R0 ; On effectue le branchement conditionnel vers done qui stoppe le programme. Exercice : R\u00e9aliser un programme qui prend deux nombres et qui retourne le plus petit. Exercice : Traduire le programme python ci-dessous en assembleur x = 0 // on met en memoire dans la variable nomme x la valeur 0 while x < 3 : x = x + 1 print ( x )","title":"Exemple 2"},{"location":"Premiere/neumann/#lassembleur-et-le-python","text":"En python aussi, on peut avoir une id\u00e9e de ce qui est traduit en langage machine gr\u00e2ce \u00e0 la biblioth\u00e8que dis comme dans l\u2019exemple suivant. Taper l\u2019exemple suivant dans un \u00e9diteur Python et observer. import dis dis . dis ( \u2019 x = 1 ; x = x + 1 \u2019 ) Exercice : Traduire en assembleur AQA (celui que nous avons vu) le langage d\u2019assemblage issu du python.","title":"L\u2019assembleur et le python"},{"location":"Premiere/neumann/#bibliographie","text":"Le site de David Roche Le site des enseignants du lyc\u00e9e Blaise Pascal \u00e0 Saint-Dizier Le simulateur ainsi que la documentation en anglais Le site du Yeti Le livre Num\u00e9rique et Sciences Informatiques aux \u00e9ditions ellipses de Thibaut Balabonski, Sylvain Conchon, Jean-Christophe Filli\u00e2tre et Kim Nguyen. C C++ #include <stdio.h> int main ( void ) { printf ( \"Hello world! \\n \" ); return 0 ; } #include <iostream> int main ( void ) { std :: cout << \"Hello world!\" << std :: endl ; return 0 ; }","title":"Bibliographie"},{"location":"Premiere/web_1NSI/","text":"Cr\u00e9er ses propres pages web # 1) Introduction # Nous consultons tous les jours des sites Web. Pour les sites les plus connus, on peut s\u2019apercevoir que l\u2019affichage et les fonctionnalit\u00e9s sont identiques quel que soit le navigateur utilis\u00e9 (ce n\u2019est pas toujours le cas pour des sites moins connus) \u00e0 quelques d\u00e9tails pr\u00e8s. Les pages Web sont cr\u00e9\u00e9es \u00e0 l\u2019aide de langages informatiques. Le respect des r\u00e8gles d\u00e9finiespour ces langages permet de cr\u00e9er des pages WEB qui pourront \u00eatre lues correctement quel que soit le navigateur. Pour cr\u00e9er la page Web visualis\u00e9e, ont \u00e9t\u00e9 utilis\u00e9s les langages HTML et CSS. Le langage HTML a \u00e9t\u00e9 cr\u00e9\u00e9 en 1991 par Tim Berners-Lee. Ce dernier a aussi cr\u00e9\u00e9 le World Wide WebConsortium (W3C) qui d\u00e9finit les nouvelles versions et les standards des langages li\u00e9s au Web. 2) Cr\u00e9er ses propres pages web # 2.1) HTML et \u00e9diteurs # Pour cr\u00e9er des pages Web, on peut utiliser: Des logiciels WYSIWYG (What You See Is What You Get); ce sont des programmes(Mozilla Composer, Dreamweaver et m\u00eame les traitements de texte) qui permettent de cr\u00e9er des sites sans apprendre de langage particulier. Les pages web sont g\u00e9n\u00e9r\u00e9s automatiquement. Permettant une cr\u00e9ation plus rapide au d\u00e9marrage, ils pr\u00e9sentent cependant l\u2019inconv\u00e9nient de modifications plus laborieuses (le codage n\u2019est pas optimis\u00e9,rendant toute modification probl\u00e9matique) Des \u00e9diteurs de texte, ce sont des programmes d\u00e9di\u00e9s \u00e0 l'\u00e9criture de code (pas seulement HTML ou CSS) plus ou moins \u00e9volu\u00e9s (les fonctionnalit\u00e9s de certains facilitent l'\u00e9criture du code). Nous utiliserons l'\u00e9diteur de texte Visual Studio Code Pour t\u00e9l\u00e9charger ce logiciel, il faut se rendre \u00e0 l\u2019adresse suivante : https://code.visualstudio.com 2.2) Ma premi\u00e8re page # Dans vos documents, cr\u00e9er un dossier nomm\u00e9 monPremierSite . Puis dans ce dossier, cr\u00e9er \u00e0 nouveau un dossier nomm\u00e9 img pour les images. Ouvrir Visual Studio Code et cr\u00e9er un nouveau document. Pour cela, il faut cliquer sur File dans la barre d\u2019outil puis New File >. Puis saisir le code suivant (ou bien faites un Copier/Coller \u00e0 partir du TP ) : See the Pen FirstPage by eric ( @ga78523 ) on CodePen . Enregistrer votre fichier sous le dossier monPremierSite sous le nom de : pageWeb1.html. Bien v\u00e9rifier, que l\u2019extension de votre fichier est .html et non .txt Sous Visual Studio Code , les balises apparaissent en bleu, les commentaires en vert et le texte visible par l\u2019utilisateur en blanc. Si vous ne voyez pas cette coloration syntaxique, appeler le professeur. Une fois enregistr\u00e9 votre travail, ouvrir votre fichier pageWeb1.html avec un navigateur internet (Firefox, Chrome, Explorer ...) Modifier le code pr\u00e9c\u00e9dent pour obtenir ceci: 2.3) Le langage HTML # Le langage HTML (HyperText Markup Language) permet de concevoir des documents Web. Ce langage de programmation descriptif est compos\u00e9 d'\u00e9l\u00e9ments. Un \u00e9l\u00e9ment HTML est compos\u00e9 d'une balise ouvrante et d'une balise fermante afin de d\u00e9limiter la zone de texte concern\u00e9e par l'\u00e9l\u00e9ment en question. Par exemple, l'\u00e9l\u00e9ment p, que nous avons utilis\u00e9 d\u00e9limite un paragraphe de texte, a pour balise ouvrante et pour balise fermante . Il y a \u00e9galement la balise <!DOCTYPE html>. Le doctype (pour Document Type Declaration) permet de renseigner le navigateur Web sur la version de HTML utilis\u00e9e par le document Web. Le doctype utilis\u00e9 dans l'exemple fait r\u00e9f\u00e9rence \u00e0 HTML5. Un fichier HTML est compos\u00e9 de deux parties. et : les \u00e9l\u00e9ments contenus dans l'ent\u00eate n'ont pas vocation \u00e0 \u00eatre affich\u00e9s sauf l'\u00e9l\u00e9ment title dont le contenu appara\u00eet dans l'onglet du navigateur Web. Les informations contenues dans l'ent\u00eate renseignent sur l'auteur et le contenu du document. et : l'ensemble des informations contenues entre ces balises sont affich\u00e9es dans la fen\u00eatre du navigateur Web. 2.4) Structuration des documents # Titre de section : les balises h1, h3, h3, h4, h5, h6 permettent de d\u00e9finir des titres de sections, sous-sections, etc jusqu\u2019\u00e0 six niveaux. Balises de texte : Balises R\u00f4le et Mise en gras et Mise en italique et soulignement et mise en indice et mise en exposant et code et texte surlign\u00e9 Structuration du document. La balise repr\u00e9sente un paragraphe. Les espaces et les retours \u00e0 la lignes sont ignor\u00e9s. Chaque nouvel \u00e9l\u00e9ment p cr\u00e9e un nouveau paragraphe. Dans la balise body, on peut placer l\u2019attribut bgcolor=\"# 33CCFF\". Celui-ci permet de colorer le fond d\u2019\u00e9cran d\u2019une certaine couleur (ici: le bleu clair). Attention: la couleur est \u00e9crite en hexad\u00e9cimal. Cela nous donne: 2.5) Travail \u00e0 faire # Rechercher sur internet et \u00e9crire ci-dessous, le code hexad\u00e9cimal du: du blanc : ........... du vert : ........... du rouge : ........... du jaune: ........... du magenta : ......... du cyan : .......... du gris fonc\u00e9 : ...... R\u00e9aliser une page internet qui se nommera pageWeb2 et qui ressemble \u00e0 celle ci-dessous avec : un titre ; deux paragraphes \u00e9crits s\u00e9par\u00e9 par un ligne ; un fond d\u2019\u00e9cran de couleur gris ; un mot mis en \u00e9vidence. Remarque: pour cr\u00e9er un paragraphe imaginaire, vous taper lorem puis entrer. En effet, on sait depuis longtemps que travailler avec du texte lisiblee t contenant du sens est source de distractions, et emp\u00eache de se concentrer sur la mise en page elle-m\u00eame. 2.6) Les images # On peut ins\u00e9rer une image (au format png, jpeg ou gif) qui se trouve sans le dossier img du dossier monPremierSite gr\u00e2ce \u00e0 la balise . Donc pour ins\u00e9rer une image (smiley.gif pr\u00e9alablement enregistr\u00e9e dans le dossier img ), on peut proc\u00e9der de la mani\u00e8re suivante : \"\"\" < img src=\"Img/smiley.gif\" alt=\"Smiley face\" width=\"42\" height=\"42\" > \"\"\" D\u00e9taillons cette ligne: src=\"smiley.gif\" donne le nom de la photo \u00e0 afficher (smiley.gif). Cet attribut est obligatoire. alt=\"Smiley face\" sp\u00e9cifie un texte alternatif si l\u2019image ne s\u2019affiche pas (Smiley face). Cet attribut est recommand\u00e9. 2.7) Les liens # HTML (Hyper Text Markup Language) est un langage hypertexte, cela signifie qu'il vous permet en cliquant sur un mot, g\u00e9n\u00e9ralement soulign\u00e9 (ou une image) de vous rendre : sur un autre endroit de la page ; sur un autre fichier HTML situ\u00e9 sur votre ordinateur. sur un autre ordinateur en r\u00e9seau, y compris sur le Web. Pour \u00e9crire un lien sur une page web, il faut adopter la syntaxe suivante: < a href=\"lien\"> texte <\\a> avec: texte: texte qui appara\u00eet en bleu soulign\u00e9 dans la page lien: adresse d\u2019un site site (Exemple : https://fr.wikipedia.org/wiki/Informatique) , d\u2019une autre page html situ\u00e9e dans notre dossier monPremierSite (exemple: pageWeb3.html \u00e0 cr\u00e9erult\u00e9rieurement) ou bien un mot dans la page web concern\u00e9e. Exemple: voir code et r\u00e9sultat pr\u00e9c\u00e9dents 2.8) Travail \u00e0 faire # R\u00e9aliser deux pages internet qui ont chacune : Un titre ; Deux paragraphes ; Une image de 300 pixels de largeurs entre les deux paragraphes et la m\u00eame image \u00e0la fin ; Un fond d\u2019\u00e9cran de couleur ; Un lien pour l\u2019autre page et un lien vers un fichier existant. 2.9) Les listes # On peut organiser le texte en liste. Une liste \u00e9num\u00e9r\u00e9e est contenue dans un \u00e9l\u00e9ment ol (abr\u00e9viation de l\u2019anglais ordered list). Une liste non-\u00e9num\u00e9r\u00e9e est contenue dans un \u00e9l\u00e9ment ul (abr\u00e9viation de l\u2019anglais unordered list). Quelque soit le type de liste, chaque entr\u00e9e de liste est contenue dans un \u00e9l\u00e9ment li. Les listes peuvent \u00e9videmment \u00eatre imbriqu\u00e9es Pour en savoir plus... # Pour conna\u00eetre d\u2019autres balises et d\u2019autres attributs, consulter le site MDN. 3) Le CSS (Cascading Style Sheets) # 3.1) Introduction # Vous avez remarqu\u00e9 que si nous voulons donner une unit\u00e9 au site, il est n\u00e9cessaire, pour chaque page, de d\u00e9finir par exemple une police bleue. Or, nous pouvons aussi utiliser une page de style \u00e9crite dans un autre langage: le CSS. Le Langage CSS, apparu en 1996, est compl\u00e9mentaire du langage HTML et permet de g\u00e9rer la mise en forme (l'apparence) des diff\u00e9rentes pages d\u2019un site Web (couleur du texte, police, taille du texte, bordures, fond...) Ainsi, dans l\u2019exemple pr\u00e9c\u00e9dent, il suffit de cr\u00e9er une page style.css (avec Visual StudioCode par exemple) dans laquelle il \u00e9crit que les paragraphes sont en bleu. Toutes les pages html cr\u00e9\u00e9es appelleront style.css dans l\u2019en-t\u00eate (head) de la page gr\u00e2ce \u00e0 l\u2019instruction : < link href = \"style.css\" rel = \"stylesheet\" type = \"text /css\" > 3.2) Explications # Ici, on indique que l\u2019\u00e9l\u00e9ment p (paragraphe) contient du texte align\u00e9 des deux c\u00f4t\u00e9s (justifi\u00e9) et de couleur bleue. On indique \u00e9galement que l\u2019\u00e9l\u00e9ment body (corps de la page HTML) aura un fond d\u2019\u00e9cran couleur gainsboro c\u2019est-\u00e0-dire bleu tr\u00e8s clair. En CSS: Body et p sont nomm\u00e9s selecteur color, text-align, background-color sont nomm\u00e9s propri\u00e9t\u00e9s CSS gainsboro, blue, justify sont nomm\u00e9s valeurs 3.3) La notion de boite # Dans le mod\u00e8le des feuilles de style, tous les \u00e9l\u00e9ments d\u2019une page HTML se coulent dans des blocs (ou \u00abboites\u00bb) rectangulaires. Un bloc typique est repr\u00e9sent\u00e9 ci-dessous : A partir de l\u2019ext\u00e9rieur, on rencontre successivement 4 zones: Une marge externe (margin), toujours transparente, avec des \u00e9paisseurs r\u00e9glables c\u00f4t\u00e9 par c\u00f4t\u00e9 ; Une bordure (border) dont on peut r\u00e9gler l\u2019\u00e9paisseur, la couleur et le style c\u00f4t\u00e9 par c\u00f4t\u00e9 ; Une marge interne (padding), ou \u00abespacement\u00bb, d\u2019\u00e9paisseur r\u00e9glable c\u00f4t\u00e9 par c\u00f4t\u00e9 ; L\u2019espace d\u00e9volu au bloc Il existe en HTML deux cat\u00e9gories d\u2019\u00e9l\u00e9ments textuels : les \u00e9l\u00e9ments block (les \u00e9l\u00e9ments p, ul sont par d\u00e9faut des \u00e9l\u00e9ments block) qui cr\u00e9ent une boite et forcent un retour \u00e0 la ligne et les \u00e9l\u00e9ments de type inline (les \u00e9l\u00e9ments a, b, i sont par d\u00e9faut des \u00e9l\u00e9ments inline) qui placentleur contenu dans le flot du texte. Il est possible faire passer des \u00e9l\u00e9ments inline en \u00e9l\u00e9ments block(et inversement \u00e0 l\u2019aide de la propri\u00e9t\u00e9 display. 3.4) Quelques propri\u00e9t\u00e9s CSS # De nombreuses propri\u00e9t\u00e9s CSS indiquent des longueurs (taille d\u2019une bordure, d\u2019un ajustement, taille des polices). Leur valeur est toujours un nombre suivi d\u2019une unit\u00e9. Parmi les unit\u00e9s l\u00e9gales en CSS, on retrouve notamment le pixel (px) et le point (pt). Nous donnons ci-dessous quelques propri\u00e9t\u00e9s CSS. Propri\u00e9t\u00e9 Valeur Description display None, block ou inline mode d\u2019affichage de la bo\u00eete Background couleur couleur de fond de la bo\u00eete color couleur couleur de texte border taille motif couleur ou none Si none, la bordure est masqu\u00e9e. Sinon, on donne la taille, le motif (solid, dotted oudashed) et la couleur s\u00e9par\u00e9s par des espaces. margin longueur taille des marges padding longueur taille des ajustements text-decoration none, underline, overline, ouline-through d\u00e9coration du texte text-align left, right, ou justify justification du texte font-family fixed, serif, ou sans serif justification du texte font-weight normal, light, bold, ou bolder graisse de la police font-style normal ou italic style de la police font-size Longueur ou xx-small, x-small,small, normal, large, x-large,xx-large taille de la police 3.5) Les balises div et span et les class # Les \u00e9l\u00e9ments div sont des balises de type bloc tandis que les \u00e9l\u00e9ments span sont des balises de types inline. Elles sont surtout utiles pour \"d\u00e9connecter\" certains morceaux de paragraphe ou plusieurs paragraphes de cette logique d'\u00e9criture avec des feuilles de style. Elles cr\u00e9ent ainsi des petits blocs particuliers dans le document sans devoir repasser par les \u00e9l\u00e9ments structurels du Html classique. Les attributs class et id sont des attributs universels ce qui signifie qu\u2019on va pouvoir les utiliser avecn\u2019importe quel \u00e9l\u00e9ment HTML, et notamment avec les \u00e9l\u00e9ments div et span.En pratique, il va \u00eatre tr\u00e8s courant de pr\u00e9ciser des attributs class et id pour nos \u00e9l\u00e9ments div et span pour pouvoir appliquer des styles \u00e0 un div (ou span) ou \u00e0 un groupe d\u2019\u00e9l\u00e9ments div ou span) d\u00e9finis. 3.6) Les tableaux # On peut enfin organiser du texte dans des tableaux au moyen de l\u2019\u00e9l\u00e9ment table, qui contient l\u2019ensemble des lignes du tableau, chacune d\u2019elle consistant en un \u00e9l\u00e9ment tr (abr\u00e9viation del\u2019anglais table row). Enfin chaque ligne d\u00e9crit les cases qu\u2019elle contient au moyen de l\u2019\u00e9l\u00e9ment td. 3.7) Pour en savoir plus... # Vous pouvez aller sur le site W3S o\u00f9 il existe un validateur HTML5 et sur le site de Pierre Giraud ( site ).","title":"web"},{"location":"Premiere/web_1NSI/#creer-ses-propres-pages-web","text":"","title":"Cr\u00e9er ses propres pages web"},{"location":"Premiere/web_1NSI/#1-introduction","text":"Nous consultons tous les jours des sites Web. Pour les sites les plus connus, on peut s\u2019apercevoir que l\u2019affichage et les fonctionnalit\u00e9s sont identiques quel que soit le navigateur utilis\u00e9 (ce n\u2019est pas toujours le cas pour des sites moins connus) \u00e0 quelques d\u00e9tails pr\u00e8s. Les pages Web sont cr\u00e9\u00e9es \u00e0 l\u2019aide de langages informatiques. Le respect des r\u00e8gles d\u00e9finiespour ces langages permet de cr\u00e9er des pages WEB qui pourront \u00eatre lues correctement quel que soit le navigateur. Pour cr\u00e9er la page Web visualis\u00e9e, ont \u00e9t\u00e9 utilis\u00e9s les langages HTML et CSS. Le langage HTML a \u00e9t\u00e9 cr\u00e9\u00e9 en 1991 par Tim Berners-Lee. Ce dernier a aussi cr\u00e9\u00e9 le World Wide WebConsortium (W3C) qui d\u00e9finit les nouvelles versions et les standards des langages li\u00e9s au Web.","title":"1) Introduction"},{"location":"Premiere/web_1NSI/#2-creer-ses-propres-pages-web","text":"","title":"2) Cr\u00e9er ses propres pages web"},{"location":"Premiere/web_1NSI/#21-html-et-editeurs","text":"Pour cr\u00e9er des pages Web, on peut utiliser: Des logiciels WYSIWYG (What You See Is What You Get); ce sont des programmes(Mozilla Composer, Dreamweaver et m\u00eame les traitements de texte) qui permettent de cr\u00e9er des sites sans apprendre de langage particulier. Les pages web sont g\u00e9n\u00e9r\u00e9s automatiquement. Permettant une cr\u00e9ation plus rapide au d\u00e9marrage, ils pr\u00e9sentent cependant l\u2019inconv\u00e9nient de modifications plus laborieuses (le codage n\u2019est pas optimis\u00e9,rendant toute modification probl\u00e9matique) Des \u00e9diteurs de texte, ce sont des programmes d\u00e9di\u00e9s \u00e0 l'\u00e9criture de code (pas seulement HTML ou CSS) plus ou moins \u00e9volu\u00e9s (les fonctionnalit\u00e9s de certains facilitent l'\u00e9criture du code). Nous utiliserons l'\u00e9diteur de texte Visual Studio Code Pour t\u00e9l\u00e9charger ce logiciel, il faut se rendre \u00e0 l\u2019adresse suivante : https://code.visualstudio.com","title":"2.1) HTML et \u00e9diteurs"},{"location":"Premiere/web_1NSI/#22-ma-premiere-page","text":"Dans vos documents, cr\u00e9er un dossier nomm\u00e9 monPremierSite . Puis dans ce dossier, cr\u00e9er \u00e0 nouveau un dossier nomm\u00e9 img pour les images. Ouvrir Visual Studio Code et cr\u00e9er un nouveau document. Pour cela, il faut cliquer sur File dans la barre d\u2019outil puis New File >. Puis saisir le code suivant (ou bien faites un Copier/Coller \u00e0 partir du TP ) : See the Pen FirstPage by eric ( @ga78523 ) on CodePen . Enregistrer votre fichier sous le dossier monPremierSite sous le nom de : pageWeb1.html. Bien v\u00e9rifier, que l\u2019extension de votre fichier est .html et non .txt Sous Visual Studio Code , les balises apparaissent en bleu, les commentaires en vert et le texte visible par l\u2019utilisateur en blanc. Si vous ne voyez pas cette coloration syntaxique, appeler le professeur. Une fois enregistr\u00e9 votre travail, ouvrir votre fichier pageWeb1.html avec un navigateur internet (Firefox, Chrome, Explorer ...) Modifier le code pr\u00e9c\u00e9dent pour obtenir ceci:","title":"2.2) Ma premi\u00e8re page"},{"location":"Premiere/web_1NSI/#23-le-langage-html","text":"Le langage HTML (HyperText Markup Language) permet de concevoir des documents Web. Ce langage de programmation descriptif est compos\u00e9 d'\u00e9l\u00e9ments. Un \u00e9l\u00e9ment HTML est compos\u00e9 d'une balise ouvrante et d'une balise fermante afin de d\u00e9limiter la zone de texte concern\u00e9e par l'\u00e9l\u00e9ment en question. Par exemple, l'\u00e9l\u00e9ment p, que nous avons utilis\u00e9 d\u00e9limite un paragraphe de texte, a pour balise ouvrante et pour balise fermante . Il y a \u00e9galement la balise <!DOCTYPE html>. Le doctype (pour Document Type Declaration) permet de renseigner le navigateur Web sur la version de HTML utilis\u00e9e par le document Web. Le doctype utilis\u00e9 dans l'exemple fait r\u00e9f\u00e9rence \u00e0 HTML5. Un fichier HTML est compos\u00e9 de deux parties. et : les \u00e9l\u00e9ments contenus dans l'ent\u00eate n'ont pas vocation \u00e0 \u00eatre affich\u00e9s sauf l'\u00e9l\u00e9ment title dont le contenu appara\u00eet dans l'onglet du navigateur Web. Les informations contenues dans l'ent\u00eate renseignent sur l'auteur et le contenu du document. et : l'ensemble des informations contenues entre ces balises sont affich\u00e9es dans la fen\u00eatre du navigateur Web.","title":"2.3) Le langage HTML"},{"location":"Premiere/web_1NSI/#24-structuration-des-documents","text":"Titre de section : les balises h1, h3, h3, h4, h5, h6 permettent de d\u00e9finir des titres de sections, sous-sections, etc jusqu\u2019\u00e0 six niveaux. Balises de texte : Balises R\u00f4le et Mise en gras et Mise en italique et soulignement et mise en indice et mise en exposant et code et texte surlign\u00e9 Structuration du document. La balise repr\u00e9sente un paragraphe. Les espaces et les retours \u00e0 la lignes sont ignor\u00e9s. Chaque nouvel \u00e9l\u00e9ment p cr\u00e9e un nouveau paragraphe. Dans la balise body, on peut placer l\u2019attribut bgcolor=\"# 33CCFF\". Celui-ci permet de colorer le fond d\u2019\u00e9cran d\u2019une certaine couleur (ici: le bleu clair). Attention: la couleur est \u00e9crite en hexad\u00e9cimal. Cela nous donne:","title":"2.4) Structuration des documents"},{"location":"Premiere/web_1NSI/#25-travail-a-faire","text":"Rechercher sur internet et \u00e9crire ci-dessous, le code hexad\u00e9cimal du: du blanc : ........... du vert : ........... du rouge : ........... du jaune: ........... du magenta : ......... du cyan : .......... du gris fonc\u00e9 : ...... R\u00e9aliser une page internet qui se nommera pageWeb2 et qui ressemble \u00e0 celle ci-dessous avec : un titre ; deux paragraphes \u00e9crits s\u00e9par\u00e9 par un ligne ; un fond d\u2019\u00e9cran de couleur gris ; un mot mis en \u00e9vidence. Remarque: pour cr\u00e9er un paragraphe imaginaire, vous taper lorem puis entrer. En effet, on sait depuis longtemps que travailler avec du texte lisiblee t contenant du sens est source de distractions, et emp\u00eache de se concentrer sur la mise en page elle-m\u00eame.","title":"2.5) Travail \u00e0 faire"},{"location":"Premiere/web_1NSI/#26-les-images","text":"On peut ins\u00e9rer une image (au format png, jpeg ou gif) qui se trouve sans le dossier img du dossier monPremierSite gr\u00e2ce \u00e0 la balise . Donc pour ins\u00e9rer une image (smiley.gif pr\u00e9alablement enregistr\u00e9e dans le dossier img ), on peut proc\u00e9der de la mani\u00e8re suivante : \"\"\" < img src=\"Img/smiley.gif\" alt=\"Smiley face\" width=\"42\" height=\"42\" > \"\"\" D\u00e9taillons cette ligne: src=\"smiley.gif\" donne le nom de la photo \u00e0 afficher (smiley.gif). Cet attribut est obligatoire. alt=\"Smiley face\" sp\u00e9cifie un texte alternatif si l\u2019image ne s\u2019affiche pas (Smiley face). Cet attribut est recommand\u00e9.","title":"2.6) Les images"},{"location":"Premiere/web_1NSI/#27-les-liens","text":"HTML (Hyper Text Markup Language) est un langage hypertexte, cela signifie qu'il vous permet en cliquant sur un mot, g\u00e9n\u00e9ralement soulign\u00e9 (ou une image) de vous rendre : sur un autre endroit de la page ; sur un autre fichier HTML situ\u00e9 sur votre ordinateur. sur un autre ordinateur en r\u00e9seau, y compris sur le Web. Pour \u00e9crire un lien sur une page web, il faut adopter la syntaxe suivante: < a href=\"lien\"> texte <\\a> avec: texte: texte qui appara\u00eet en bleu soulign\u00e9 dans la page lien: adresse d\u2019un site site (Exemple : https://fr.wikipedia.org/wiki/Informatique) , d\u2019une autre page html situ\u00e9e dans notre dossier monPremierSite (exemple: pageWeb3.html \u00e0 cr\u00e9erult\u00e9rieurement) ou bien un mot dans la page web concern\u00e9e. Exemple: voir code et r\u00e9sultat pr\u00e9c\u00e9dents","title":"2.7) Les liens"},{"location":"Premiere/web_1NSI/#28-travail-a-faire","text":"R\u00e9aliser deux pages internet qui ont chacune : Un titre ; Deux paragraphes ; Une image de 300 pixels de largeurs entre les deux paragraphes et la m\u00eame image \u00e0la fin ; Un fond d\u2019\u00e9cran de couleur ; Un lien pour l\u2019autre page et un lien vers un fichier existant.","title":"2.8) Travail \u00e0 faire"},{"location":"Premiere/web_1NSI/#29-les-listes","text":"On peut organiser le texte en liste. Une liste \u00e9num\u00e9r\u00e9e est contenue dans un \u00e9l\u00e9ment ol (abr\u00e9viation de l\u2019anglais ordered list). Une liste non-\u00e9num\u00e9r\u00e9e est contenue dans un \u00e9l\u00e9ment ul (abr\u00e9viation de l\u2019anglais unordered list). Quelque soit le type de liste, chaque entr\u00e9e de liste est contenue dans un \u00e9l\u00e9ment li. Les listes peuvent \u00e9videmment \u00eatre imbriqu\u00e9es","title":"2.9) Les listes"},{"location":"Premiere/web_1NSI/#pour-en-savoir-plus","text":"Pour conna\u00eetre d\u2019autres balises et d\u2019autres attributs, consulter le site MDN.","title":"Pour en savoir plus..."},{"location":"Premiere/web_1NSI/#3-le-css-cascading-style-sheets","text":"","title":"3) Le CSS (Cascading Style Sheets)"},{"location":"Premiere/web_1NSI/#31-introduction","text":"Vous avez remarqu\u00e9 que si nous voulons donner une unit\u00e9 au site, il est n\u00e9cessaire, pour chaque page, de d\u00e9finir par exemple une police bleue. Or, nous pouvons aussi utiliser une page de style \u00e9crite dans un autre langage: le CSS. Le Langage CSS, apparu en 1996, est compl\u00e9mentaire du langage HTML et permet de g\u00e9rer la mise en forme (l'apparence) des diff\u00e9rentes pages d\u2019un site Web (couleur du texte, police, taille du texte, bordures, fond...) Ainsi, dans l\u2019exemple pr\u00e9c\u00e9dent, il suffit de cr\u00e9er une page style.css (avec Visual StudioCode par exemple) dans laquelle il \u00e9crit que les paragraphes sont en bleu. Toutes les pages html cr\u00e9\u00e9es appelleront style.css dans l\u2019en-t\u00eate (head) de la page gr\u00e2ce \u00e0 l\u2019instruction : < link href = \"style.css\" rel = \"stylesheet\" type = \"text /css\" >","title":"3.1) Introduction"},{"location":"Premiere/web_1NSI/#32-explications","text":"Ici, on indique que l\u2019\u00e9l\u00e9ment p (paragraphe) contient du texte align\u00e9 des deux c\u00f4t\u00e9s (justifi\u00e9) et de couleur bleue. On indique \u00e9galement que l\u2019\u00e9l\u00e9ment body (corps de la page HTML) aura un fond d\u2019\u00e9cran couleur gainsboro c\u2019est-\u00e0-dire bleu tr\u00e8s clair. En CSS: Body et p sont nomm\u00e9s selecteur color, text-align, background-color sont nomm\u00e9s propri\u00e9t\u00e9s CSS gainsboro, blue, justify sont nomm\u00e9s valeurs","title":"3.2) Explications"},{"location":"Premiere/web_1NSI/#33-la-notion-de-boite","text":"Dans le mod\u00e8le des feuilles de style, tous les \u00e9l\u00e9ments d\u2019une page HTML se coulent dans des blocs (ou \u00abboites\u00bb) rectangulaires. Un bloc typique est repr\u00e9sent\u00e9 ci-dessous : A partir de l\u2019ext\u00e9rieur, on rencontre successivement 4 zones: Une marge externe (margin), toujours transparente, avec des \u00e9paisseurs r\u00e9glables c\u00f4t\u00e9 par c\u00f4t\u00e9 ; Une bordure (border) dont on peut r\u00e9gler l\u2019\u00e9paisseur, la couleur et le style c\u00f4t\u00e9 par c\u00f4t\u00e9 ; Une marge interne (padding), ou \u00abespacement\u00bb, d\u2019\u00e9paisseur r\u00e9glable c\u00f4t\u00e9 par c\u00f4t\u00e9 ; L\u2019espace d\u00e9volu au bloc Il existe en HTML deux cat\u00e9gories d\u2019\u00e9l\u00e9ments textuels : les \u00e9l\u00e9ments block (les \u00e9l\u00e9ments p, ul sont par d\u00e9faut des \u00e9l\u00e9ments block) qui cr\u00e9ent une boite et forcent un retour \u00e0 la ligne et les \u00e9l\u00e9ments de type inline (les \u00e9l\u00e9ments a, b, i sont par d\u00e9faut des \u00e9l\u00e9ments inline) qui placentleur contenu dans le flot du texte. Il est possible faire passer des \u00e9l\u00e9ments inline en \u00e9l\u00e9ments block(et inversement \u00e0 l\u2019aide de la propri\u00e9t\u00e9 display.","title":"3.3) La notion de boite"},{"location":"Premiere/web_1NSI/#34-quelques-proprietes-css","text":"De nombreuses propri\u00e9t\u00e9s CSS indiquent des longueurs (taille d\u2019une bordure, d\u2019un ajustement, taille des polices). Leur valeur est toujours un nombre suivi d\u2019une unit\u00e9. Parmi les unit\u00e9s l\u00e9gales en CSS, on retrouve notamment le pixel (px) et le point (pt). Nous donnons ci-dessous quelques propri\u00e9t\u00e9s CSS. Propri\u00e9t\u00e9 Valeur Description display None, block ou inline mode d\u2019affichage de la bo\u00eete Background couleur couleur de fond de la bo\u00eete color couleur couleur de texte border taille motif couleur ou none Si none, la bordure est masqu\u00e9e. Sinon, on donne la taille, le motif (solid, dotted oudashed) et la couleur s\u00e9par\u00e9s par des espaces. margin longueur taille des marges padding longueur taille des ajustements text-decoration none, underline, overline, ouline-through d\u00e9coration du texte text-align left, right, ou justify justification du texte font-family fixed, serif, ou sans serif justification du texte font-weight normal, light, bold, ou bolder graisse de la police font-style normal ou italic style de la police font-size Longueur ou xx-small, x-small,small, normal, large, x-large,xx-large taille de la police","title":"3.4) Quelques propri\u00e9t\u00e9s CSS"},{"location":"Premiere/web_1NSI/#35-les-balises-div-et-span-et-les-class","text":"Les \u00e9l\u00e9ments div sont des balises de type bloc tandis que les \u00e9l\u00e9ments span sont des balises de types inline. Elles sont surtout utiles pour \"d\u00e9connecter\" certains morceaux de paragraphe ou plusieurs paragraphes de cette logique d'\u00e9criture avec des feuilles de style. Elles cr\u00e9ent ainsi des petits blocs particuliers dans le document sans devoir repasser par les \u00e9l\u00e9ments structurels du Html classique. Les attributs class et id sont des attributs universels ce qui signifie qu\u2019on va pouvoir les utiliser avecn\u2019importe quel \u00e9l\u00e9ment HTML, et notamment avec les \u00e9l\u00e9ments div et span.En pratique, il va \u00eatre tr\u00e8s courant de pr\u00e9ciser des attributs class et id pour nos \u00e9l\u00e9ments div et span pour pouvoir appliquer des styles \u00e0 un div (ou span) ou \u00e0 un groupe d\u2019\u00e9l\u00e9ments div ou span) d\u00e9finis.","title":"3.5) Les balises div et span et les class"},{"location":"Premiere/web_1NSI/#36-les-tableaux","text":"On peut enfin organiser du texte dans des tableaux au moyen de l\u2019\u00e9l\u00e9ment table, qui contient l\u2019ensemble des lignes du tableau, chacune d\u2019elle consistant en un \u00e9l\u00e9ment tr (abr\u00e9viation del\u2019anglais table row). Enfin chaque ligne d\u00e9crit les cases qu\u2019elle contient au moyen de l\u2019\u00e9l\u00e9ment td.","title":"3.6) Les tableaux"},{"location":"Premiere/web_1NSI/#37-pour-en-savoir-plus","text":"Vous pouvez aller sur le site W3S o\u00f9 il existe un validateur HTML5 et sur le site de Pierre Giraud ( site ).","title":"3.7) Pour en savoir plus..."},{"location":"SNT/image/","text":"Activit\u00e9 : traitement de l'image # Pr\u00e9alable # Sur l'ENT, dans la rubrique Ressources , aller sur Capytale puis Acc\u00e9dez \u00e0 vos activit\u00e9s puis dans Acc\u00e9der \u00e0 une activit\u00e9 (voir ci-dessous), rentrer le code donn\u00e9. vous avez ouvert un fichier qui comporte deux images (non visibles ici). Pour v\u00e9rifier qu'il fonctionne, taper le code suivant dans une cellule: 1 2 3 4 from PIL import Image mon_image = Image . open ( \"buse.jpg\" ) mon_image . show () Apr\u00e8s avoir importer la biblioth\u00e8que PIL (pour Python Imaging Library ),ce code ouvre la photo buse.jpg et la place en m\u00e9moire sous le nom de mon_image . Puis on demande au programme de nous l'afficher. Remarque : Pour en conna\u00eetre plus sur cette biblioth\u00e8que de traitement d\u2019image, vous pouvez consulter cette page . Exercice 1.1 : Ouvrir l'image rose.jpg .Nommer la variable rose puis l'afficher. Conna\u00eetre la largeur et la longueur en pixel d'une image # On peut conna\u00eetre la largeur et la longueur en pixel d'une image \u00e0 l'aide des instructions with et height . Exemple : 1 2 3 4 5 6 7 from PIL import Image mon_image = Image . open ( \"buse.jpg\" ) largeur_image = mon_image . width longueur_image = mon_image . height print ( \"La largeur vaut :\" , largeur_image , \" px et la longueur vaut :\" , longueur_image , \" px\" ) mon_image . show () Exercice 2.1 : R\u00e9aliser un programme qui d\u00e9termine la largeur et la longueur de l'image rose.jpg et qui l'affiche mais qui n'affiche pas l'image. Obtenir les composantes RVB d'un pixel # Exercice 3.1 : Ex\u00e9cuter le code suivant (Copier/coller) : A quoi sert la fonction getpixel(x,y) ? A quoi correspondent les trois nombres du triplet r,v,b ? Pouvait-on pr\u00e9voir en regardant l'image buse.jpg , que la valeur de b serait la plus \u00e9lev\u00e9 ? R\u00e9aliser un programme qui affiche la couleur (composantes RVB) du pixel de coordonn\u00e9es x = 300 et y= 80. 1 2 3 4 5 from PIL import Image mon_image = Image . open ( \"buse.jpg\" ) #Cette image a une dimension de 400\u00d7200 pixels. Le pixel (0,0) est en haut \u00e0 gauche. r , v , b = mon_image . getpixel (( 10 , 10 )) print ( r , v , b ) Parcourir une zone # La fonction putpixel # Exercice 4.1 : Ex\u00e9cuter le code suivant. A quoi sert la fonction putpixel((x,y),(R,V,B)) ? Que va faire le code suivant ? 1 2 3 4 5 from PIL import Image mon_image = Image . open ( \"buse.jpg\" ) #Cette image a une dimension de 400\u00d7200 pixels for x in range ( 400 ): mon_image . putpixel ( ( x , 20 ),( 255 , 255 , 255 )) mon_image . show () Dessiner avec PIL # Le code suivant r\u00e9alise le drapeau fran\u00e7ais. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from PIL import Image # cr\u00e9ation d'une image de 400 px de large et de 200 px de haut mon_image = Image . new ( 'RGB' ,( 400 , 200 )) # zone bleue for x in range ( 133 ): # on balaie x de 0 \u00e0 132 for y in range ( 200 ): # on balaie y de 0 \u00e0 199 mon_image . putpixel ( ( x , y ),( 0 , 0 , 255 )) # On renmplit les points de coordonn\u00e9es (x, y) de bleu #zone blanche for x in range ( 133 , 266 ): # on balaie x de 133 \u00e0 265 for y in range ( 200 ): # on balaie y de 0 \u00e0 199 mon_image . putpixel ( ( x , y ),( 255 , 255 , 255 )) # zone rouge for x in range ( 266 , 400 ): # on balaie x de 266 \u00e0 400 for y in range ( 200 ): # on balaie y de 0 \u00e0 199 mon_image . putpixel ( ( x , y ),( 255 , 0 , 0 )) # affichage du drapeau mon_image . show () Exercice 4.2 : R\u00e9aliser un drapeau italien. Exercice 4.3 : R\u00e9aliser un drapeau Colombien. Exercice 4.4 : R\u00e9aliser un drapeau suisse Traitement de l'image # L'image en niveau de gris # Ex\u00e9cuter le script suivant : 1 2 3 4 5 6 7 8 9 10 11 from PIL import Image mon_image1 = Image . open ( \"buse.jpg\" ) #Cette image a une dimension de 400\u00d7200 pixels mon_image2 = Image . new ( 'RGB' ,( 400 , 200 )) #Cr\u00e9e une seconde a une dimension de 400\u00d7200 pixels for x in range ( 400 ): for y in range ( 200 ): r , v , b = mon_image1 . getpixel (( x , y )) #r,v,b prennent les valeurs des composante RVB du pixel (x,y) de Image1 g = ( r + v + b ) // 3 mon_image2 . putpixel ( ( x , y ),( g , g , g )) #On fixe la couleur du pixel (x,y) de Image2 mon_image2 . save ( \"Buse en Gris.jpg\" ) #On enregistre cette image mon_image2 . show () Remarque : on utilise la division enti\u00e8re avec l'op\u00e9rateur // (Par exemple : 7 //2 renvoie 3) pour calculer les couleurs des pixels de la nouvelle image. Conservation d'une composante # 1 2 3 4 5 6 7 8 9 10 from PIL import Image mon_image1 = Image . open ( \"buse.jpg\" ) #Cette image a une dimension de 400\u00d7200 pixels mon_image3 = Image . new ( 'RGB' ,( 400 , 200 )) #Cr\u00e9e une seconde a une dimension de 400\u00d7200 pixels for x in range ( 400 ): for y in range ( 200 ): r , v , b = mon_image1 . getpixel (( x , y )) #r,v,b prennent les valeurs des composante RVB du pixel (x,y) de Image1 mon_image3 . putpixel ( ( x , y ),( r , 0 , 0 )) #On fixe la couleur du pixel (x,y) de Image2 mon_image3 . save ( \"Buse en Rouge.jpg\" ) #On enregistre cette image mon_image3 . show () Exercice 5.1 : R\u00e9aliser un programme qui effectue la conservation de la composante verte de l'image rose.jpg . Seuillage : # L\u2019id\u00e9e est de modifier le programme pr\u00e9c\u00e9dent pour que si la moyenne de ses trois composantes est sup\u00e9rieure \u00e0 90, le pixel correspondant dans l\u2019image devient blanc, et si cette moyenne est inf\u00e9rieure \u00e0 90, le pixel devient noir. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from PIL import Image mon_image1 = Image . open ( \"buse.jpg\" ) #Cette image a une dimension de 400\u00d7200 pixels mon_image4 = Image . new ( 'RGB' ,( 400 , 200 )) #Cr\u00e9e une seconde a une dimension de 400\u00d7200 pixels for x in range ( 400 ): for y in range ( 200 ): r , v , b = mon_image1 . getpixel (( x , y )) #r,v,b prennent les valeurs des composante RVB du pixel (x,y) de Image1 m = ( r + v + b ) // 3 if m > 90 : mon_image4 . putpixel ( ( x , y ),( 255 , 255 , 255 )) #On fixe la couleur du pixel (x,y) de Image2 else : mon_image4 . putpixel ( ( x , y ),( 0 , 0 , 0 )) #On fixe la couleur du pixel (x,y) de Image2 mon_image4 . save ( \"Buse Seuill\u00e9e.jpg\" ) #On enregistre cette image mon_image4 . show () Remarque : On peut \u00e9videmment changer la valeur du seuil pour obtenir d\u2019autres effets. Exercice 5.2 : R\u00e9aliser un programme qui effectue le sueillage de la rose avec un seuil \u00e9gal \u00e0 125 rose.jpg . Changement de dominante # On utilise maintenant la photo rose.jpg . On souhaite changer les couleurs des roses dont la dominante est rouge (r > v et r > b). On peut par exemple choisir : si un pixel a une dominante rouge, on divise par deux sa composante rouge. 1 2 3 4 5 6 7 8 9 10 11 12 13 from PIL import Image mon_image1 = Image . open ( \"rose.jpg\" ) #Cette image a une dimension de 400\u00d7300 pixels mon_image5 = Image . new ( 'RGB' ,( 400 , 300 )) for x in range ( 400 ): for y in range ( 300 ): r , v , b = mon_image1 . getpixel (( x , y )) #r,v,b prennent les valeurs des composante RVB du pixel (x,y) de Image1 if r > v and r > b : mon_image5 . putpixel ( ( x , y ),( r // 2 , v , b )) #On fixe la couleur du pixel (x,y) de Image2 else : mon_image5 . putpixel ( ( x , y ),( r , v , b )) #On fixe la couleur du pixel (x,y) de Image2 mon_image5 . save ( \"Rose sans Dominante Rouge.jpg\" ) #On enregistre cette image mon_image5 . show () Exercices # Exercice 6.1 : sym\u00e9trie A partir de l'image iguane.jpg disponible dans l'activit\u00e9. R\u00e9aliser le programme qui r\u00e9alise la sym\u00e9trie suivante. Exercice 6.2 : sym\u00e9trie A partir de l'image iguane.jpg disponible dans l'activit\u00e9. R\u00e9aliser le programme qui r\u00e9alise le n\u00e9gatif de cette image. Remarque : Obtenir le n\u00e9gatif d'une image est tr\u00e8s simple : toutes les composantes x de tous les pixels de l'image sont remplac\u00e9es par 255-x.","title":"traitement de l'image"},{"location":"SNT/image/#activite-traitement-de-limage","text":"","title":" Activit\u00e9 : traitement de l'image "},{"location":"SNT/image/#prealable","text":"Sur l'ENT, dans la rubrique Ressources , aller sur Capytale puis Acc\u00e9dez \u00e0 vos activit\u00e9s puis dans Acc\u00e9der \u00e0 une activit\u00e9 (voir ci-dessous), rentrer le code donn\u00e9. vous avez ouvert un fichier qui comporte deux images (non visibles ici). Pour v\u00e9rifier qu'il fonctionne, taper le code suivant dans une cellule: 1 2 3 4 from PIL import Image mon_image = Image . open ( \"buse.jpg\" ) mon_image . show () Apr\u00e8s avoir importer la biblioth\u00e8que PIL (pour Python Imaging Library ),ce code ouvre la photo buse.jpg et la place en m\u00e9moire sous le nom de mon_image . Puis on demande au programme de nous l'afficher. Remarque : Pour en conna\u00eetre plus sur cette biblioth\u00e8que de traitement d\u2019image, vous pouvez consulter cette page . Exercice 1.1 : Ouvrir l'image rose.jpg .Nommer la variable rose puis l'afficher.","title":"Pr\u00e9alable"},{"location":"SNT/image/#connaitre-la-largeur-et-la-longueur-en-pixel-dune-image","text":"On peut conna\u00eetre la largeur et la longueur en pixel d'une image \u00e0 l'aide des instructions with et height . Exemple : 1 2 3 4 5 6 7 from PIL import Image mon_image = Image . open ( \"buse.jpg\" ) largeur_image = mon_image . width longueur_image = mon_image . height print ( \"La largeur vaut :\" , largeur_image , \" px et la longueur vaut :\" , longueur_image , \" px\" ) mon_image . show () Exercice 2.1 : R\u00e9aliser un programme qui d\u00e9termine la largeur et la longueur de l'image rose.jpg et qui l'affiche mais qui n'affiche pas l'image.","title":"Conna\u00eetre la largeur et la longueur en pixel d'une image"},{"location":"SNT/image/#obtenir-les-composantes-rvb-dun-pixel","text":"Exercice 3.1 : Ex\u00e9cuter le code suivant (Copier/coller) : A quoi sert la fonction getpixel(x,y) ? A quoi correspondent les trois nombres du triplet r,v,b ? Pouvait-on pr\u00e9voir en regardant l'image buse.jpg , que la valeur de b serait la plus \u00e9lev\u00e9 ? R\u00e9aliser un programme qui affiche la couleur (composantes RVB) du pixel de coordonn\u00e9es x = 300 et y= 80. 1 2 3 4 5 from PIL import Image mon_image = Image . open ( \"buse.jpg\" ) #Cette image a une dimension de 400\u00d7200 pixels. Le pixel (0,0) est en haut \u00e0 gauche. r , v , b = mon_image . getpixel (( 10 , 10 )) print ( r , v , b )","title":"Obtenir les composantes RVB d'un pixel"},{"location":"SNT/image/#parcourir-une-zone","text":"","title":"Parcourir une zone"},{"location":"SNT/image/#la-fonction-putpixel","text":"Exercice 4.1 : Ex\u00e9cuter le code suivant. A quoi sert la fonction putpixel((x,y),(R,V,B)) ? Que va faire le code suivant ? 1 2 3 4 5 from PIL import Image mon_image = Image . open ( \"buse.jpg\" ) #Cette image a une dimension de 400\u00d7200 pixels for x in range ( 400 ): mon_image . putpixel ( ( x , 20 ),( 255 , 255 , 255 )) mon_image . show ()","title":"La fonction putpixel"},{"location":"SNT/image/#dessiner-avec-pil","text":"Le code suivant r\u00e9alise le drapeau fran\u00e7ais. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from PIL import Image # cr\u00e9ation d'une image de 400 px de large et de 200 px de haut mon_image = Image . new ( 'RGB' ,( 400 , 200 )) # zone bleue for x in range ( 133 ): # on balaie x de 0 \u00e0 132 for y in range ( 200 ): # on balaie y de 0 \u00e0 199 mon_image . putpixel ( ( x , y ),( 0 , 0 , 255 )) # On renmplit les points de coordonn\u00e9es (x, y) de bleu #zone blanche for x in range ( 133 , 266 ): # on balaie x de 133 \u00e0 265 for y in range ( 200 ): # on balaie y de 0 \u00e0 199 mon_image . putpixel ( ( x , y ),( 255 , 255 , 255 )) # zone rouge for x in range ( 266 , 400 ): # on balaie x de 266 \u00e0 400 for y in range ( 200 ): # on balaie y de 0 \u00e0 199 mon_image . putpixel ( ( x , y ),( 255 , 0 , 0 )) # affichage du drapeau mon_image . show () Exercice 4.2 : R\u00e9aliser un drapeau italien. Exercice 4.3 : R\u00e9aliser un drapeau Colombien. Exercice 4.4 : R\u00e9aliser un drapeau suisse","title":"Dessiner avec PIL"},{"location":"SNT/image/#traitement-de-limage","text":"","title":"Traitement de l'image"},{"location":"SNT/image/#limage-en-niveau-de-gris","text":"Ex\u00e9cuter le script suivant : 1 2 3 4 5 6 7 8 9 10 11 from PIL import Image mon_image1 = Image . open ( \"buse.jpg\" ) #Cette image a une dimension de 400\u00d7200 pixels mon_image2 = Image . new ( 'RGB' ,( 400 , 200 )) #Cr\u00e9e une seconde a une dimension de 400\u00d7200 pixels for x in range ( 400 ): for y in range ( 200 ): r , v , b = mon_image1 . getpixel (( x , y )) #r,v,b prennent les valeurs des composante RVB du pixel (x,y) de Image1 g = ( r + v + b ) // 3 mon_image2 . putpixel ( ( x , y ),( g , g , g )) #On fixe la couleur du pixel (x,y) de Image2 mon_image2 . save ( \"Buse en Gris.jpg\" ) #On enregistre cette image mon_image2 . show () Remarque : on utilise la division enti\u00e8re avec l'op\u00e9rateur // (Par exemple : 7 //2 renvoie 3) pour calculer les couleurs des pixels de la nouvelle image.","title":"L'image en niveau de gris"},{"location":"SNT/image/#conservation-dune-composante","text":"1 2 3 4 5 6 7 8 9 10 from PIL import Image mon_image1 = Image . open ( \"buse.jpg\" ) #Cette image a une dimension de 400\u00d7200 pixels mon_image3 = Image . new ( 'RGB' ,( 400 , 200 )) #Cr\u00e9e une seconde a une dimension de 400\u00d7200 pixels for x in range ( 400 ): for y in range ( 200 ): r , v , b = mon_image1 . getpixel (( x , y )) #r,v,b prennent les valeurs des composante RVB du pixel (x,y) de Image1 mon_image3 . putpixel ( ( x , y ),( r , 0 , 0 )) #On fixe la couleur du pixel (x,y) de Image2 mon_image3 . save ( \"Buse en Rouge.jpg\" ) #On enregistre cette image mon_image3 . show () Exercice 5.1 : R\u00e9aliser un programme qui effectue la conservation de la composante verte de l'image rose.jpg .","title":"Conservation d'une composante"},{"location":"SNT/image/#seuillage","text":"L\u2019id\u00e9e est de modifier le programme pr\u00e9c\u00e9dent pour que si la moyenne de ses trois composantes est sup\u00e9rieure \u00e0 90, le pixel correspondant dans l\u2019image devient blanc, et si cette moyenne est inf\u00e9rieure \u00e0 90, le pixel devient noir. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from PIL import Image mon_image1 = Image . open ( \"buse.jpg\" ) #Cette image a une dimension de 400\u00d7200 pixels mon_image4 = Image . new ( 'RGB' ,( 400 , 200 )) #Cr\u00e9e une seconde a une dimension de 400\u00d7200 pixels for x in range ( 400 ): for y in range ( 200 ): r , v , b = mon_image1 . getpixel (( x , y )) #r,v,b prennent les valeurs des composante RVB du pixel (x,y) de Image1 m = ( r + v + b ) // 3 if m > 90 : mon_image4 . putpixel ( ( x , y ),( 255 , 255 , 255 )) #On fixe la couleur du pixel (x,y) de Image2 else : mon_image4 . putpixel ( ( x , y ),( 0 , 0 , 0 )) #On fixe la couleur du pixel (x,y) de Image2 mon_image4 . save ( \"Buse Seuill\u00e9e.jpg\" ) #On enregistre cette image mon_image4 . show () Remarque : On peut \u00e9videmment changer la valeur du seuil pour obtenir d\u2019autres effets. Exercice 5.2 : R\u00e9aliser un programme qui effectue le sueillage de la rose avec un seuil \u00e9gal \u00e0 125 rose.jpg .","title":"Seuillage :"},{"location":"SNT/image/#changement-de-dominante","text":"On utilise maintenant la photo rose.jpg . On souhaite changer les couleurs des roses dont la dominante est rouge (r > v et r > b). On peut par exemple choisir : si un pixel a une dominante rouge, on divise par deux sa composante rouge. 1 2 3 4 5 6 7 8 9 10 11 12 13 from PIL import Image mon_image1 = Image . open ( \"rose.jpg\" ) #Cette image a une dimension de 400\u00d7300 pixels mon_image5 = Image . new ( 'RGB' ,( 400 , 300 )) for x in range ( 400 ): for y in range ( 300 ): r , v , b = mon_image1 . getpixel (( x , y )) #r,v,b prennent les valeurs des composante RVB du pixel (x,y) de Image1 if r > v and r > b : mon_image5 . putpixel ( ( x , y ),( r // 2 , v , b )) #On fixe la couleur du pixel (x,y) de Image2 else : mon_image5 . putpixel ( ( x , y ),( r , v , b )) #On fixe la couleur du pixel (x,y) de Image2 mon_image5 . save ( \"Rose sans Dominante Rouge.jpg\" ) #On enregistre cette image mon_image5 . show ()","title":"Changement de dominante"},{"location":"SNT/image/#exercices","text":"Exercice 6.1 : sym\u00e9trie A partir de l'image iguane.jpg disponible dans l'activit\u00e9. R\u00e9aliser le programme qui r\u00e9alise la sym\u00e9trie suivante. Exercice 6.2 : sym\u00e9trie A partir de l'image iguane.jpg disponible dans l'activit\u00e9. R\u00e9aliser le programme qui r\u00e9alise le n\u00e9gatif de cette image. Remarque : Obtenir le n\u00e9gatif d'une image est tr\u00e8s simple : toutes les composantes x de tous les pixels de l'image sont remplac\u00e9es par 255-x.","title":"Exercices"},{"location":"Terminale/cours/","text":"Syst\u00e8mes sur puce # 1. Loi de Moore et miniaturisation progressive # 1.1 La Loi de Moore # En 1965, Gordon Moore postule que le nombre de transistors pr\u00e9sents sur une puce de microprocesseur doublera tous les deux ans. Cette pr\u00e9diction s'est r\u00e9v\u00e9l\u00e9e \u00e9tonnamment juste (\u00e0 quelques approximations pr\u00e8s) et les \u00e9quipements \u00e9lectroniques n'ont depuis jamais cess\u00e9 de devenir toujours plus performants / miniatures / \u00e9conomes en \u00e9nergie. 1.2 \u00c9volution de la taille des ordinateurs # 1.2.1 IBM 650, le premier ordinateur fabriqu\u00e9 en s\u00e9rie (1955) # Cet ordinateur n'a pas encore de transistors mais des tubes \u00e0 vide. 1.2.2 IBM 7090, le premier ordinateur \u00e0 transistors (1959) # Le transistor est un composant \u00e9lectronique essentiel : il permet de laisser (ou non) passer un courant \u00e9lectrique. 1.2.3 Le r\u00f4le crucial de la taille des transistors # Ainsi que l'avait pr\u00e9dit Moore, c'est la progression du nombre de transistors gravables sur le processeur qui guidera pendant des ann\u00e9es l'\u00e9volution de l'informatique : Le transistor est un composant \u00e9lectronique essentiel : il permet de laisser (ou non) passer un courant \u00e9lectrique. 2. Composition d'un pc actuel # Chaque composant a un r\u00f4le sp\u00e9cifique. Ils communiquent entre eux par des bus de diff\u00e9rentes vitesses. Chaque composant est rempla\u00e7able, et il est possible d'ajouter de nouveaux composants sur la carte m\u00e8re qui poss\u00e8de des slots d'extension. 3. Tout un pc sur une seule puce : les SoC # 3.1 L'int\u00e9gration de composants diff\u00e9rents au sein d'une m\u00eame puce # Le principe d'un syst\u00e8me sur puce ou System On a Chip (SoC) est d'int\u00e9grer au sein d'une puce unique un ensemble de composants habituellement physiquement dissoci\u00e9s dans un ordinateur classique (ordinateur de bureau ou ordinateur portable). On peut retrouver ainsi au sein d'une m\u00eame puce : le microprocesseur (CPU) la carte graphique (GPU) la m\u00e9moire RAM + \u00e9ventuellement des composants de communication (WiFi, Bluetooth...) Avantages et inconv\u00e9nients d'un SoC :heart: :white_check_mark: Avantages moindre consommation \u00e9lectrique moindre encombrement pas besoin de refroidissement meilleure s\u00e9curit\u00e9 (vue globale sur la s\u00e9curit\u00e9 qui n'est plus d\u00e9pendante d'une multitude de composants) moindre co\u00fbt (forte automisation du processus, gros volumes de production) :name_badge: Inconv\u00e9nients Impossibilit\u00e9 de choisir ind\u00e9pendamment ses composants Pas de mise \u00e0 jour possible / remplacement / ajout d'un composant La panne d'un seul composant entra\u00eene la panne totale du SoC 3.2 Exemple : A15 Bionic # Observons par exemple la puce Apple A15 Bionic, qui \u00e9quipe les iPhone 13. Cette puce est fabriqu\u00e9e par TSMC . Cette puce contient : 15 milliards de transistors (grav\u00e9s \u00e0 5 nm) un processeur central \u00e0 6 c\u0153urs (2 c\u0153urs hautes performances + 4 c\u0153urs plus \u00e9conomes en \u00e9nergie) un GPU (processeur d\u00e9di\u00e9 uniquement au calcul du rendu graphique) de 5 c\u0153urs. une puce d\u00e9di\u00e9e au Machine Learning ( Neural Engine ) 4. Des puces d\u00e9di\u00e9es \u00e0 des t\u00e2ches sp\u00e9cifiques # L'int\u00e9gration dans un SoC n'est pas totale : il reste des puces d\u00e9di\u00e9es \u00e0 des t\u00e2ches tr\u00e8s sp\u00e9cifiques qui ne sont pas forc\u00e9ment int\u00e9gr\u00e9es dans le SoC. 4.1 Au sein d'un t\u00e9l\u00e9phone # Ainsi, d'apr\u00e8s le site iFixit , on peut retrouver ceci dans l'iPhone Pro 13, au c\u00f4t\u00e9 de la puce A15 \u00e9voqu\u00e9e plus haut : On voit que (par exemple) qu'il existe une puce sp\u00e9cifique pour g\u00e9rer l'audio, une puce sp\u00e9cifique pour le module WiFi, une puce sp\u00e9cifique pour le module Modem 5G... 4.2 En \u00e9lectronique \u00abgrand public\u00bb # Ce composant (pouvant \u00eatre utilis\u00e9 dans un montage personnel, sur un Arduino par exemple) ne sert qu'\u00e0 faire des calculs cryptographiques. 4.3 Un principe g\u00e9n\u00e9ral # Il est important de comprendre que certains processeurs sont optimis\u00e9s pour un certains types de calcul. C'est le cas par exemple d'une carte graphique, qui excelle dans le calcul de rendus de polygones. On s'est aper\u00e7u que cette aptitude \u00e0 faire des calculs \u00abb\u00eates et r\u00e9p\u00e9titifs\u00bb \u00e9tait parfaite pour faire les calculs math\u00e9matiques (inutiles) n\u00e9cessaires au minage des cryptomonnaies. Les cartes graphiques ont donc \u00e9t\u00e9 d\u00e9tourn\u00e9es de leur usage originel, \u00e0 cause de la sp\u00e9cificit\u00e9 de l'impl\u00e9mentation de leur puce. De m\u00eame, les calculs sur les r\u00e9seaux de neurones (essentiels en IA) n\u00e9cessitent une grande rapidit\u00e9 dans les multiplications de matrices. Pour cette raison, Apple a int\u00e9gr\u00e9 directement dans son SoC A15 une puce sp\u00e9calis\u00e9e dans ces calculs (voir plus haut). 4.4 Conclusion # L'orientation actuelle de l'\u00e9lectronique est donc \u00e0 la fois : une int\u00e9gration toujours plus grande dans des SoC multi-t\u00e2ches. des puces toujours plus sp\u00e9cifiques qui excellent dans un domaine particulier. 5. Exercice # Exercice (Polyn\u00e9sie 2021) Un constructeur automobile int\u00e8gre \u00e0 ses v\u00e9hicules des syst\u00e8mes embarqu\u00e9s, comme par exemple un syst\u00e8me de guidage par satellites (GPS), un syst\u00e8me de freinage antiblocage (ABS)... Ces dispositifs utilisent des syst\u00e8mes sur puces (SoC : System on a Chip). Citer deux avantages \u00e0 utiliser ces syst\u00e8mes sur puces plut\u00f4t qu'une architecture classique d'ordinateur. \"Bibliographie / Sitographie\" - Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. - Pr\u00e9pabac NSI, Terminale, G.CONNAN, V.PETROV, G.ROZSAVOLGYI, L.SIGNAC, \u00e9ditions HATIER. - https://fr.wikipedia.org/wiki/Loi_de_Moore - https://blog.iakaa.com/lordinateur-fete-ses-60-ans/ - https://www.thewindowsclub.com/history-of-computers - https://perso-etis.ensea.fr//lorandel/M2_SoC/s1.pdf - https://www.hawkpointtechnologies.com/about/blog/computer-components - https://www.tremplin-numerique.org/apple-a15-vs-a14-quoi-de-neuf-dans-la-puce-de-liphone-13 - https://www.distrelec.be/fr/cryptoprocesseur-breakout-atecc608a-sparkfun-electronics-dev-18077/p/30241877","title":"SOC"},{"location":"Terminale/cours/#systemes-sur-puce","text":"","title":"Syst\u00e8mes sur puce"},{"location":"Terminale/cours/#1-loi-de-moore-et-miniaturisation-progressive","text":"","title":"1. Loi de Moore et miniaturisation progressive"},{"location":"Terminale/cours/#11-la-loi-de-moore","text":"En 1965, Gordon Moore postule que le nombre de transistors pr\u00e9sents sur une puce de microprocesseur doublera tous les deux ans. Cette pr\u00e9diction s'est r\u00e9v\u00e9l\u00e9e \u00e9tonnamment juste (\u00e0 quelques approximations pr\u00e8s) et les \u00e9quipements \u00e9lectroniques n'ont depuis jamais cess\u00e9 de devenir toujours plus performants / miniatures / \u00e9conomes en \u00e9nergie.","title":"1.1 La Loi de Moore"},{"location":"Terminale/cours/#12-evolution-de-la-taille-des-ordinateurs","text":"","title":"1.2  \u00c9volution de la taille des ordinateurs"},{"location":"Terminale/cours/#2-composition-dun-pc-actuel","text":"Chaque composant a un r\u00f4le sp\u00e9cifique. Ils communiquent entre eux par des bus de diff\u00e9rentes vitesses. Chaque composant est rempla\u00e7able, et il est possible d'ajouter de nouveaux composants sur la carte m\u00e8re qui poss\u00e8de des slots d'extension.","title":"2. Composition d'un pc actuel"},{"location":"Terminale/cours/#3-tout-un-pc-sur-une-seule-puce-les-soc","text":"","title":"3. Tout un pc sur une seule puce : les SoC"},{"location":"Terminale/cours/#31-lintegration-de-composants-differents-au-sein-dune-meme-puce","text":"Le principe d'un syst\u00e8me sur puce ou System On a Chip (SoC) est d'int\u00e9grer au sein d'une puce unique un ensemble de composants habituellement physiquement dissoci\u00e9s dans un ordinateur classique (ordinateur de bureau ou ordinateur portable). On peut retrouver ainsi au sein d'une m\u00eame puce : le microprocesseur (CPU) la carte graphique (GPU) la m\u00e9moire RAM + \u00e9ventuellement des composants de communication (WiFi, Bluetooth...) Avantages et inconv\u00e9nients d'un SoC :heart: :white_check_mark: Avantages moindre consommation \u00e9lectrique moindre encombrement pas besoin de refroidissement meilleure s\u00e9curit\u00e9 (vue globale sur la s\u00e9curit\u00e9 qui n'est plus d\u00e9pendante d'une multitude de composants) moindre co\u00fbt (forte automisation du processus, gros volumes de production) :name_badge: Inconv\u00e9nients Impossibilit\u00e9 de choisir ind\u00e9pendamment ses composants Pas de mise \u00e0 jour possible / remplacement / ajout d'un composant La panne d'un seul composant entra\u00eene la panne totale du SoC","title":"3.1 L'int\u00e9gration de composants diff\u00e9rents au sein d'une m\u00eame puce"},{"location":"Terminale/cours/#32-exemple-a15-bionic","text":"Observons par exemple la puce Apple A15 Bionic, qui \u00e9quipe les iPhone 13. Cette puce est fabriqu\u00e9e par TSMC . Cette puce contient : 15 milliards de transistors (grav\u00e9s \u00e0 5 nm) un processeur central \u00e0 6 c\u0153urs (2 c\u0153urs hautes performances + 4 c\u0153urs plus \u00e9conomes en \u00e9nergie) un GPU (processeur d\u00e9di\u00e9 uniquement au calcul du rendu graphique) de 5 c\u0153urs. une puce d\u00e9di\u00e9e au Machine Learning ( Neural Engine )","title":"3.2 Exemple : A15 Bionic"},{"location":"Terminale/cours/#4-des-puces-dediees-a-des-taches-specifiques","text":"L'int\u00e9gration dans un SoC n'est pas totale : il reste des puces d\u00e9di\u00e9es \u00e0 des t\u00e2ches tr\u00e8s sp\u00e9cifiques qui ne sont pas forc\u00e9ment int\u00e9gr\u00e9es dans le SoC.","title":"4. Des puces d\u00e9di\u00e9es \u00e0 des t\u00e2ches sp\u00e9cifiques"},{"location":"Terminale/cours/#41-au-sein-dun-telephone","text":"Ainsi, d'apr\u00e8s le site iFixit , on peut retrouver ceci dans l'iPhone Pro 13, au c\u00f4t\u00e9 de la puce A15 \u00e9voqu\u00e9e plus haut : On voit que (par exemple) qu'il existe une puce sp\u00e9cifique pour g\u00e9rer l'audio, une puce sp\u00e9cifique pour le module WiFi, une puce sp\u00e9cifique pour le module Modem 5G...","title":"4.1 Au sein d'un t\u00e9l\u00e9phone"},{"location":"Terminale/cours/#42-en-electronique-grand-public","text":"Ce composant (pouvant \u00eatre utilis\u00e9 dans un montage personnel, sur un Arduino par exemple) ne sert qu'\u00e0 faire des calculs cryptographiques.","title":"4.2 En \u00e9lectronique \u00abgrand public\u00bb"},{"location":"Terminale/cours/#43-un-principe-general","text":"Il est important de comprendre que certains processeurs sont optimis\u00e9s pour un certains types de calcul. C'est le cas par exemple d'une carte graphique, qui excelle dans le calcul de rendus de polygones. On s'est aper\u00e7u que cette aptitude \u00e0 faire des calculs \u00abb\u00eates et r\u00e9p\u00e9titifs\u00bb \u00e9tait parfaite pour faire les calculs math\u00e9matiques (inutiles) n\u00e9cessaires au minage des cryptomonnaies. Les cartes graphiques ont donc \u00e9t\u00e9 d\u00e9tourn\u00e9es de leur usage originel, \u00e0 cause de la sp\u00e9cificit\u00e9 de l'impl\u00e9mentation de leur puce. De m\u00eame, les calculs sur les r\u00e9seaux de neurones (essentiels en IA) n\u00e9cessitent une grande rapidit\u00e9 dans les multiplications de matrices. Pour cette raison, Apple a int\u00e9gr\u00e9 directement dans son SoC A15 une puce sp\u00e9calis\u00e9e dans ces calculs (voir plus haut).","title":"4.3 Un principe g\u00e9n\u00e9ral"},{"location":"Terminale/cours/#44-conclusion","text":"L'orientation actuelle de l'\u00e9lectronique est donc \u00e0 la fois : une int\u00e9gration toujours plus grande dans des SoC multi-t\u00e2ches. des puces toujours plus sp\u00e9cifiques qui excellent dans un domaine particulier.","title":"4.4 Conclusion"},{"location":"Terminale/cours/#5-exercice","text":"Exercice (Polyn\u00e9sie 2021) Un constructeur automobile int\u00e8gre \u00e0 ses v\u00e9hicules des syst\u00e8mes embarqu\u00e9s, comme par exemple un syst\u00e8me de guidage par satellites (GPS), un syst\u00e8me de freinage antiblocage (ABS)... Ces dispositifs utilisent des syst\u00e8mes sur puces (SoC : System on a Chip). Citer deux avantages \u00e0 utiliser ces syst\u00e8mes sur puces plut\u00f4t qu'une architecture classique d'ordinateur. \"Bibliographie / Sitographie\" - Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. - Pr\u00e9pabac NSI, Terminale, G.CONNAN, V.PETROV, G.ROZSAVOLGYI, L.SIGNAC, \u00e9ditions HATIER. - https://fr.wikipedia.org/wiki/Loi_de_Moore - https://blog.iakaa.com/lordinateur-fete-ses-60-ans/ - https://www.thewindowsclub.com/history-of-computers - https://perso-etis.ensea.fr//lorandel/M2_SoC/s1.pdf - https://www.hawkpointtechnologies.com/about/blog/computer-components - https://www.tremplin-numerique.org/apple-a15-vs-a14-quoi-de-neuf-dans-la-puce-de-liphone-13 - https://www.distrelec.be/fr/cryptoprocesseur-breakout-atecc608a-sparkfun-electronics-dev-18077/p/30241877","title":"5. Exercice"},{"location":"Terminale/imprimantes/","text":"R\u00e9aliser des mod\u00e8les 3D # R\u00e9aliser ses propres mod\u00e8les gr\u00e2ce \u00e0 des logiciels de CAO # solidworks # SOLIDWORKS est un logiciel propri\u00e9taire de conception assist\u00e9e par ordinateur 3D fonctionnant sous Windows. C'est un logiciel d\u00e9velopp\u00e9 par Dassault Syst\u00e8mes. Site de Solidworks fusion 360 # Fusion 360 d'Autodesk est un logiciel CAO polyvalent qui propose toutes les fonctionnalit\u00e9s n\u00e9cessaires au d\u00e9veloppement de produits, depuis la phase de conception \u00e0 la v\u00e9rification pour fabrication avec des outils de fabrication traditionnelle ou num\u00e9rique comme l'impression 3D. Il est disponible sous windows et sous Mac. Site de Fusion 360 FreeCAD # Comme l\u2019indique son nom FreeCAD est gratuit. Pour ce logiciel de mod\u00e9lisation 3D param\u00e9trique, aucune autre exp\u00e9rience n\u2019est n\u00e9cessaire, il peut \u00eatre utilis\u00e9 imm\u00e9diatement pour cr\u00e9er des mod\u00e8les 3D complexes. Le logiciel s\u2019int\u00e9resse particuli\u00e8rement aux projets d\u2019ing\u00e9nierie ou d\u2019architecture. Il peut \u00eatre utilis\u00e9 par n\u2019importe qui : utilisateurs \u00e0 domicile, concepteurs, programmeurs et m\u00eame \u00e9ducateurs. Il fonctionne sur Windows, Mac ainsi que Linux. Site de freeCAD Blender # Blender est un logiciel open source largement utilis\u00e9. Il propose un catalogue incroyable d\u2019outils et de logiciels pour cr\u00e9er des mod\u00e8les impressionnants tout en laissant libre cours \u00e0 votre imagination. Il peut \u00eatre utilis\u00e9 sur Mac, Windows et Linux. Cependant, si vous souhaitez utiliser Blender, il est conseill\u00e9 d\u2019avoir une petite exp\u00e9rience pr\u00e9alable avec les logiciels 3D. Site de Blender Obtenir des mod\u00e8les 3D # Vous pouvez t\u00e9l\u00e9charger un objet 3D sur un site qui rend accessible gratuitement des dizaines de milliers de mod\u00e8les tridimensionnel Vous y trouverez peut-\u00eatre votre objet ou tout simplement des id\u00e9es. Voici quelques sites : Cults3d Thingiverse Youmagine Pinshape Diff\u00e9rents types d'imprimante: # les imprimantes \u00e0 filament # Les filaments utilis\u00e9s dans l'impression 3D sont les thermoplastiques, qui sont des plastiques qui fondent plut\u00f4t lorsqu'ils sont chauff\u00e9s. Les thermoplastiques peuvent \u00eatre fa\u00e7onn\u00e9s et moul\u00e9s lorsqu'ils sont chauds et se solidifier lorsqu'ils sont refroidis. Le filament est introduit dans une chambre de chauffage dans l'assemblage de l'extrudeuse de l'imprimante, o\u00f9 il est chauff\u00e9 \u00e0 son point de fusion, puis extrud\u00e9 \u00e0 travers une buse m\u00e9tallique. Lorsque l'assemblage de l'extrudeuse se d\u00e9place, tracer un chemin programm\u00e9 dans un fichier d'objet 3D pour cr\u00e9er, couche par couche, l'objet imprim\u00e9. Les imprimantes \u00e0 r\u00e9sine # Les imprimantes \u00e0 r\u00e9sine forment des pi\u00e8ces \u00e0 partir de r\u00e9sine liquide qui durcit et devient solide lorsqu'elle est expos\u00e9e \u00e0 la lumi\u00e8re UV. Semblables aux imprimantes \u00e0 filament, les imprimantes \u00e0 r\u00e9sine construisent des pi\u00e8ces en couches. La diff\u00e9rence est qu'il se solidifie lorsqu'une pi\u00e8ce est expos\u00e9e \u00e0 la lumi\u00e8re. Chaque tranche \u00e0 un motif de lumi\u00e8re UV solidifiera la r\u00e9sine aux endroits souhait\u00e9s. Il y a trois types d'imprimantes 3D \u00e0 r\u00e9sine courantes : DLP (traitement num\u00e9rique de la lumi\u00e8re) ; SLA (st\u00e9r\u00e9olithographie) ; MSLA (microst\u00e9r\u00e9olithographie). Ces technologies diff\u00e8rent dans la fa\u00e7on dont elles durcissent la r\u00e9sine. Pour les imprimantes DLP, une fois que le mod\u00e8le 3D est envoy\u00e9 \u00e0 l\u2019imprimante, une cuve transparente de polym\u00e8re liquide appel\u00e9 photopolym\u00e8re ou plus grossi\u00e8rement r\u00e9sine, est expos\u00e9e \u00e0 la lumi\u00e8re d\u2019un projecteur DLP dans des conditions de lumi\u00e8re s\u00fbre. Ce projecteur \u00e0 \u00e9cran num\u00e9rique va projeter une image de la couche sur l\u2019ensemble de la plateforme de fabrication, gr\u00e2ce \u00e0 des miroirs. La lumi\u00e8re est r\u00e9fl\u00e9chie sur une matrice de micro-miroirs, un masque dynamique consistant de miroirs microscopiques dispos\u00e9s dans une matrice sur une puce semi-conducteur. Le d\u00e9placement rapide de ces minuscules miroirs entre les lentilles qui dirigent la lumi\u00e8re vers le fond du bac o\u00f9 un dissipateur thermique d\u00e9finit les coordonn\u00e9s o\u00f9 la r\u00e9sine liquide sera polym\u00e9ris\u00e9e dans une couche donn\u00e9e. La r\u00e9sine une fois expos\u00e9e va donc durcir et la plaque de construction (plateau de travail) sur lequel la pi\u00e8ce repose se d\u00e9place vers le bas. Apr\u00e8s cela les photopolym\u00e8res sont une fois de plus expos\u00e9s \u00e0 la lumi\u00e8re. La pi\u00e8ce se construit \u00e0 l'envers sur le plateau, couche par couche. Les imprimantes SLA utilisent un laser qui trace un chemin \u00e0 travers la r\u00e9sine. \u00c0 l'endroit o\u00f9 le laser frappe la r\u00e9sine, la r\u00e9sine durcira et se solidifiera. De l'ext\u00e9rieur, ces imprimantes sont tr\u00e8s similaires. Depuis l'essor de l'impression bas\u00e9e sur LCD (MSLA), les prix des syst\u00e8mes d'impression 3D \u00e0 base de r\u00e9sine ont baiss\u00e9 au niveau des imprimantes FDM. C'est pourquoi la plupart des imprimantes \u00e0 r\u00e9sine \u00e0 moindre co\u00fbt utilisent presque la m\u00eame technologie LCD / MSLA. Comparaison entre les deux # Les imprimantes \u00e0 filament fonctionnent bien pour produire des pi\u00e8ces aux propri\u00e9t\u00e9s thermoplastiques et sont souvent des pi\u00e8ces plus grandes. Les imprimantes \u00e0 r\u00e9sine excellent dans la production de d\u00e9tails fins et peuvent imprimer beaucoup plus pr\u00e9cis\u00e9ment sur de petites pi\u00e8ces, mais utilisent de la r\u00e9sine thermodurcissable. Il y a quelques facteurs plus importants \u00e0 consid\u00e9rer lors du choix de ces technologies qui conviennent le mieux \u00e0 vos besoins sp\u00e9cifiques. Les \u00e9tapes pour utiliser une imprimantes 3D # \u00c9tape 1 : pr\u00e9parer l\u2019impression 3D # Ouvrez votre fichier .stl ou .obj gr\u00e2ce \u00e0 un logiciel d\u2019impression 3D fourni avec votre imprimante 3D (il pourrait \u00eatre compar\u00e9 \u00e0 votre logiciel d\u2019imprimante papier). Vous pourrez alors visualiser votre objet et si besoin le d\u00e9placer sur la plateforme (zone d\u2019impression de votre machine). Avec ce logiciel, il vous sera possible aussi d\u2019agrandir ou diminuer la taille d\u2019impression de votre objet. C\u2019est aussi avec ce logiciel que vous pouvez estimer votre temps d\u2019impression. Ce temps pourra varier en fonction de param\u00e8tres qu\u2019il vous sera propos\u00e9 de modifier : la mati\u00e8re du filament avec laquelle vous imprimerez votre objet ; la qualit\u00e9 ou finesse de votre impression ; l\u2019ajout de support d\u2019impression pour les objets complexes. Il existe une multitude de logiciels pour imprimer en 3D, compatibles avec la majorit\u00e9 des imprimantes. Ces logiciels sont la majeure partie du temps en t\u00e9l\u00e9chargement libre et gratuit sur Internet. En voici quelques exemples : Cura Repetier Markerware Il est important de comprendre que c\u2019est l\u2019une des \u00e9tapes les plus importantes \u00e0 ma\u00eetriser. Une impression 3D mal configur\u00e9e dans le logiciel d\u2019impression 3D peut faire que vos temps d\u2019impression doublent, ou que votre objet ne s\u2019imprime pas ou tr\u00e8s mal. Il existe les r\u00e9glages par d\u00e9faut en fonction de la mati\u00e8re que vous utilisez. Je vous recommande vivement d\u2019utiliser ces r\u00e9glages dans un premier temps. se connecter et pr\u00e9parer votre imprimante 3D # Cette \u00e9tape peut \u00eatre compar\u00e9e \u00e0 tout point de vue \u00e0 l\u2019impression papier. Il faut connecter votre imprimante \u00e0 votre ordinateur. Il existe une multitude de fa\u00e7on de se connecter: c\u00e2ble USB, carte SD, WiFi \u2026. Il faut placer par exemple votre bobine de mati\u00e8re sur son support, puis ins\u00e9rer le filament dans l\u2019extrudeur. Il faut lancer l\u2019initialisation de votre machine. Il existe aujourd\u2019hui une quantit\u00e9 faramineuse de tutoriels vid\u00e9os sur le sujet.","title":"Imprimante"},{"location":"Terminale/imprimantes/#realiser-des-modeles-3d","text":"","title":"R\u00e9aliser des mod\u00e8les 3D"},{"location":"Terminale/imprimantes/#realiser-ses-propres-modeles-grace-a-des-logiciels-de-cao","text":"","title":"R\u00e9aliser ses propres mod\u00e8les gr\u00e2ce \u00e0 des logiciels de CAO"},{"location":"Terminale/imprimantes/#solidworks","text":"SOLIDWORKS est un logiciel propri\u00e9taire de conception assist\u00e9e par ordinateur 3D fonctionnant sous Windows. C'est un logiciel d\u00e9velopp\u00e9 par Dassault Syst\u00e8mes. Site de Solidworks","title":"solidworks"},{"location":"Terminale/imprimantes/#fusion-360","text":"Fusion 360 d'Autodesk est un logiciel CAO polyvalent qui propose toutes les fonctionnalit\u00e9s n\u00e9cessaires au d\u00e9veloppement de produits, depuis la phase de conception \u00e0 la v\u00e9rification pour fabrication avec des outils de fabrication traditionnelle ou num\u00e9rique comme l'impression 3D. Il est disponible sous windows et sous Mac. Site de Fusion 360","title":"fusion 360"},{"location":"Terminale/imprimantes/#freecad","text":"Comme l\u2019indique son nom FreeCAD est gratuit. Pour ce logiciel de mod\u00e9lisation 3D param\u00e9trique, aucune autre exp\u00e9rience n\u2019est n\u00e9cessaire, il peut \u00eatre utilis\u00e9 imm\u00e9diatement pour cr\u00e9er des mod\u00e8les 3D complexes. Le logiciel s\u2019int\u00e9resse particuli\u00e8rement aux projets d\u2019ing\u00e9nierie ou d\u2019architecture. Il peut \u00eatre utilis\u00e9 par n\u2019importe qui : utilisateurs \u00e0 domicile, concepteurs, programmeurs et m\u00eame \u00e9ducateurs. Il fonctionne sur Windows, Mac ainsi que Linux. Site de freeCAD","title":"FreeCAD"},{"location":"Terminale/imprimantes/#blender","text":"Blender est un logiciel open source largement utilis\u00e9. Il propose un catalogue incroyable d\u2019outils et de logiciels pour cr\u00e9er des mod\u00e8les impressionnants tout en laissant libre cours \u00e0 votre imagination. Il peut \u00eatre utilis\u00e9 sur Mac, Windows et Linux. Cependant, si vous souhaitez utiliser Blender, il est conseill\u00e9 d\u2019avoir une petite exp\u00e9rience pr\u00e9alable avec les logiciels 3D. Site de Blender","title":"Blender"},{"location":"Terminale/imprimantes/#obtenir-des-modeles-3d","text":"Vous pouvez t\u00e9l\u00e9charger un objet 3D sur un site qui rend accessible gratuitement des dizaines de milliers de mod\u00e8les tridimensionnel Vous y trouverez peut-\u00eatre votre objet ou tout simplement des id\u00e9es. Voici quelques sites : Cults3d Thingiverse Youmagine Pinshape","title":"Obtenir des mod\u00e8les 3D"},{"location":"Terminale/imprimantes/#differents-types-dimprimante","text":"","title":"Diff\u00e9rents types d'imprimante:"},{"location":"Terminale/imprimantes/#les-imprimantes-a-filament","text":"Les filaments utilis\u00e9s dans l'impression 3D sont les thermoplastiques, qui sont des plastiques qui fondent plut\u00f4t lorsqu'ils sont chauff\u00e9s. Les thermoplastiques peuvent \u00eatre fa\u00e7onn\u00e9s et moul\u00e9s lorsqu'ils sont chauds et se solidifier lorsqu'ils sont refroidis. Le filament est introduit dans une chambre de chauffage dans l'assemblage de l'extrudeuse de l'imprimante, o\u00f9 il est chauff\u00e9 \u00e0 son point de fusion, puis extrud\u00e9 \u00e0 travers une buse m\u00e9tallique. Lorsque l'assemblage de l'extrudeuse se d\u00e9place, tracer un chemin programm\u00e9 dans un fichier d'objet 3D pour cr\u00e9er, couche par couche, l'objet imprim\u00e9.","title":"les imprimantes \u00e0 filament"},{"location":"Terminale/imprimantes/#les-imprimantes-a-resine","text":"Les imprimantes \u00e0 r\u00e9sine forment des pi\u00e8ces \u00e0 partir de r\u00e9sine liquide qui durcit et devient solide lorsqu'elle est expos\u00e9e \u00e0 la lumi\u00e8re UV. Semblables aux imprimantes \u00e0 filament, les imprimantes \u00e0 r\u00e9sine construisent des pi\u00e8ces en couches. La diff\u00e9rence est qu'il se solidifie lorsqu'une pi\u00e8ce est expos\u00e9e \u00e0 la lumi\u00e8re. Chaque tranche \u00e0 un motif de lumi\u00e8re UV solidifiera la r\u00e9sine aux endroits souhait\u00e9s. Il y a trois types d'imprimantes 3D \u00e0 r\u00e9sine courantes : DLP (traitement num\u00e9rique de la lumi\u00e8re) ; SLA (st\u00e9r\u00e9olithographie) ; MSLA (microst\u00e9r\u00e9olithographie). Ces technologies diff\u00e8rent dans la fa\u00e7on dont elles durcissent la r\u00e9sine. Pour les imprimantes DLP, une fois que le mod\u00e8le 3D est envoy\u00e9 \u00e0 l\u2019imprimante, une cuve transparente de polym\u00e8re liquide appel\u00e9 photopolym\u00e8re ou plus grossi\u00e8rement r\u00e9sine, est expos\u00e9e \u00e0 la lumi\u00e8re d\u2019un projecteur DLP dans des conditions de lumi\u00e8re s\u00fbre. Ce projecteur \u00e0 \u00e9cran num\u00e9rique va projeter une image de la couche sur l\u2019ensemble de la plateforme de fabrication, gr\u00e2ce \u00e0 des miroirs. La lumi\u00e8re est r\u00e9fl\u00e9chie sur une matrice de micro-miroirs, un masque dynamique consistant de miroirs microscopiques dispos\u00e9s dans une matrice sur une puce semi-conducteur. Le d\u00e9placement rapide de ces minuscules miroirs entre les lentilles qui dirigent la lumi\u00e8re vers le fond du bac o\u00f9 un dissipateur thermique d\u00e9finit les coordonn\u00e9s o\u00f9 la r\u00e9sine liquide sera polym\u00e9ris\u00e9e dans une couche donn\u00e9e. La r\u00e9sine une fois expos\u00e9e va donc durcir et la plaque de construction (plateau de travail) sur lequel la pi\u00e8ce repose se d\u00e9place vers le bas. Apr\u00e8s cela les photopolym\u00e8res sont une fois de plus expos\u00e9s \u00e0 la lumi\u00e8re. La pi\u00e8ce se construit \u00e0 l'envers sur le plateau, couche par couche. Les imprimantes SLA utilisent un laser qui trace un chemin \u00e0 travers la r\u00e9sine. \u00c0 l'endroit o\u00f9 le laser frappe la r\u00e9sine, la r\u00e9sine durcira et se solidifiera. De l'ext\u00e9rieur, ces imprimantes sont tr\u00e8s similaires. Depuis l'essor de l'impression bas\u00e9e sur LCD (MSLA), les prix des syst\u00e8mes d'impression 3D \u00e0 base de r\u00e9sine ont baiss\u00e9 au niveau des imprimantes FDM. C'est pourquoi la plupart des imprimantes \u00e0 r\u00e9sine \u00e0 moindre co\u00fbt utilisent presque la m\u00eame technologie LCD / MSLA.","title":"Les imprimantes \u00e0 r\u00e9sine"},{"location":"Terminale/imprimantes/#comparaison-entre-les-deux","text":"Les imprimantes \u00e0 filament fonctionnent bien pour produire des pi\u00e8ces aux propri\u00e9t\u00e9s thermoplastiques et sont souvent des pi\u00e8ces plus grandes. Les imprimantes \u00e0 r\u00e9sine excellent dans la production de d\u00e9tails fins et peuvent imprimer beaucoup plus pr\u00e9cis\u00e9ment sur de petites pi\u00e8ces, mais utilisent de la r\u00e9sine thermodurcissable. Il y a quelques facteurs plus importants \u00e0 consid\u00e9rer lors du choix de ces technologies qui conviennent le mieux \u00e0 vos besoins sp\u00e9cifiques.","title":"Comparaison entre les deux"},{"location":"Terminale/imprimantes/#les-etapes-pour-utiliser-une-imprimantes-3d","text":"","title":"Les \u00e9tapes pour utiliser une imprimantes 3D"},{"location":"Terminale/imprimantes/#etape-1-preparer-limpression-3d","text":"Ouvrez votre fichier .stl ou .obj gr\u00e2ce \u00e0 un logiciel d\u2019impression 3D fourni avec votre imprimante 3D (il pourrait \u00eatre compar\u00e9 \u00e0 votre logiciel d\u2019imprimante papier). Vous pourrez alors visualiser votre objet et si besoin le d\u00e9placer sur la plateforme (zone d\u2019impression de votre machine). Avec ce logiciel, il vous sera possible aussi d\u2019agrandir ou diminuer la taille d\u2019impression de votre objet. C\u2019est aussi avec ce logiciel que vous pouvez estimer votre temps d\u2019impression. Ce temps pourra varier en fonction de param\u00e8tres qu\u2019il vous sera propos\u00e9 de modifier : la mati\u00e8re du filament avec laquelle vous imprimerez votre objet ; la qualit\u00e9 ou finesse de votre impression ; l\u2019ajout de support d\u2019impression pour les objets complexes. Il existe une multitude de logiciels pour imprimer en 3D, compatibles avec la majorit\u00e9 des imprimantes. Ces logiciels sont la majeure partie du temps en t\u00e9l\u00e9chargement libre et gratuit sur Internet. En voici quelques exemples : Cura Repetier Markerware Il est important de comprendre que c\u2019est l\u2019une des \u00e9tapes les plus importantes \u00e0 ma\u00eetriser. Une impression 3D mal configur\u00e9e dans le logiciel d\u2019impression 3D peut faire que vos temps d\u2019impression doublent, ou que votre objet ne s\u2019imprime pas ou tr\u00e8s mal. Il existe les r\u00e9glages par d\u00e9faut en fonction de la mati\u00e8re que vous utilisez. Je vous recommande vivement d\u2019utiliser ces r\u00e9glages dans un premier temps.","title":"\u00c9tape 1 : pr\u00e9parer l\u2019impression 3D"},{"location":"Terminale/imprimantes/#se-connecter-et-preparer-votre-imprimante-3d","text":"Cette \u00e9tape peut \u00eatre compar\u00e9e \u00e0 tout point de vue \u00e0 l\u2019impression papier. Il faut connecter votre imprimante \u00e0 votre ordinateur. Il existe une multitude de fa\u00e7on de se connecter: c\u00e2ble USB, carte SD, WiFi \u2026. Il faut placer par exemple votre bobine de mati\u00e8re sur son support, puis ins\u00e9rer le filament dans l\u2019extrudeur. Il faut lancer l\u2019initialisation de votre machine. Il existe aujourd\u2019hui une quantit\u00e9 faramineuse de tutoriels vid\u00e9os sur le sujet.","title":"se connecter et pr\u00e9parer votre imprimante 3D"},{"location":"Terminale/prog_dyn/","text":"Programmation dynamique # Contexte # Exercice 1 : \u00c9crire une fonction r\u00e9cursive qui calcule la factorielle n. Rappel : \\(n!=1\\times 2\\times 3\\times ...\\times n\\) ` \u00c9crire une fonction r\u00e9cursive qui permet de calculer le \\(n^{i\u00e8me}\\) terme de la suite de Fibonacci. Donc pour n = 6, cette deuxi\u00e8me fonction peut se repr\u00e9senter par le sch\u00e9ma ci-dessous : arbre Vous pouvez constater que l'on a une structure arborescente (typique dans les algorithmes r\u00e9cursifs), si on additionne toutes les feuilles de cette structure arborescente (fib(1) = 1 et fib(0) = 0), on retrouve bien 8. En observant attentivement le sch\u00e9ma ci-dessus, vous avez remarqu\u00e9 que de nombreux calculs sont inutiles, car effectu\u00e9 2 fois : par exemple on retrouve le calcul de fib(4) \u00e0 2 endroits (en haut \u00e0 droite et un peu plus bas \u00e0 gauche) : arbre Programmation Dynamique # Premiers exemples sur la suite de Fibonacci # En consid\u00e9rant l'algorithme pr\u00e9c\u00e9dant, on comprend bien qu'il est particuli\u00e8rement inefficace de calculer plusieurs fois le m\u00eame sous-calcul. Afin d'am\u00e9liorer le temps de calcul de l'algorithme, nous d\u00e9cidons donc de m\u00e9moriser les calculs d\u00e9j\u00e0 effectu\u00e9s dans un tableau. Il existe deux m\u00e9thodes diff\u00e9rentes : Bottom-Up Top Down On pourrait donc grandement simplifier le calcul en calculant une fois pour toutes fib(4), en \"m\u00e9morisant\" le r\u00e9sultat et en le r\u00e9utilisant quand n\u00e9cessaire. On va calculer les nombres de la suite de Fibonacci jusqu'\u00e0 \\(F(n)\\) en partant de \\(F(0)\\) et \\(F(1)\\) . On appelle ce type de m\u00e9thode une m\u00e9thode Bottom-Up. Ce n'est pas une m\u00e9thode r\u00e9cursive. 1 2 3 4 5 6 def fibo_asc ( n : int ) -> int : F = [ 0 ] * ( n + 1 ) F [ 1 ] = 1 for i in range ( 2 , n + 1 ) : F [ i ] = F [ i - 1 ] + F [ i - 2 ] return F [ n ] On va calculer les nombres de Fibonacci r\u00e9cursivement, mais en sauvegardant les calculs d\u00e9j\u00e0 effectu\u00e9s dans une liste Python, en profitant de sa mutabilit\u00e9. On appelle ce type de m\u00e9thode une approche Top-Down : 1 2 3 4 5 6 7 8 def fibo_desc ( n : int ) -> int : memo = [ 0 , 1 ] + [ None ] * ( n - 1 ) def compute ( n , memo ) : if memo [ n ] is None : memo [ n ] = compute ( n - 1 , memo ) + compute ( n - 2 , memo ) return memo [ n ] return compute ( n , memo ) Principes de la programmation dynamique # La programmation dynamique, introduite au d\u00e9but des ann\u00e9es 1950 par Richard Bellman, est une m\u00e9thode pour r\u00e9soudre des probl\u00e8mes en combinant des solutions de sous-probl\u00e8mes, tout comme les m\u00e9thodes de type diviser pour r\u00e9gner. Un algorithme de programmation dynamique r\u00e9sout chaque sous-sous-probl\u00e8me une seule fois et m\u00e9morise sa r\u00e9ponse dans un tableau, \u00e9vitant ainsi le re-calcul de la solution chaque fois qu'il r\u00e9sout chaque sous-sous-probl\u00e8me. La programmation dynamique s'applique g\u00e9n\u00e9ralement aux probl\u00e8mes d'optimisation, comme ceux que nous avons vu l'an pass\u00e9 lorsque nous avons \u00e9tudi\u00e9 les algorithmes gloutons. Application aux algorithmes gloutons # Rappels pour la version r\u00e9cursive # Vous avez \u00e0 votre disposition un nombre illimit\u00e9 de pi\u00e8ces de 2, 5 cts, 10 cts, 50 cts et 1 euro (100 cts). Vous devez rendre une certaine somme (rendu de monnaie). Le probl\u00e8me est le suivant : \"Quel est le nombre minimum de pi\u00e8ces qui doivent \u00eatre utilis\u00e9es pour rendre la monnaie\" La r\u00e9solution \"gloutonne\" de ce probl\u00e8me peut \u00eatre la suivante : On prend la pi\u00e8ce qui a la plus grande valeur (il faut que la valeur de cette pi\u00e8ce soit inf\u00e9rieure ou \u00e9gale \u00e0 la somme restant \u00e0 rendre). On recommence l\u2019op\u00e9ration ci-dessus jusqu\u2019au moment o\u00f9 la somme \u00e0 rendre est \u00e9gale \u00e0 z\u00e9ro. Exemple : nous avons 1 euro 77 cts \u00e0 rendre : on utilise une pi\u00e8ce de 1 euro (plus grande valeur de pi\u00e8ce inf\u00e9rieure \u00e0 1,77 euro), il reste 77 cts \u00e0 rendre on utilise une pi\u00e8ce de 50 cts (plus grande valeur de pi\u00e8ce inf\u00e9rieure \u00e0 0,77 euro), il reste 27 cts \u00e0 rendre on utilise une pi\u00e8ce de 10 cts (plus grande valeur de pi\u00e8ce inf\u00e9rieure \u00e0 0,27 euro), il reste 17 cts \u00e0 rendre on utilise une pi\u00e8ce de 10 cts (plus grande valeur de pi\u00e8ce inf\u00e9rieure \u00e0 0,17 euro), il reste 7 cts \u00e0 rendre on utilise une pi\u00e8ce de 5 cts (plus grande valeur de pi\u00e8ce inf\u00e9rieure \u00e0 0,07 euro), il reste 2 cts \u00e0 rendre on utilise une pi\u00e8ce de 2 cts (plus grande valeur de pi\u00e8ce inf\u00e9rieure \u00e0 0,02 euro), il reste 0 cts \u00e0 rendre. L'algorithme se termine en renvoyant 6 (on a d\u00fb rendre 6 pi\u00e8ces) Exercice : Compl\u00e9ter la fonction suivante pour qu'elle donne le nombre minimal de pi\u00e8ces utilis\u00e9es pour une somme s donn\u00e9e : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def rendu_monnaie_rec ( P : list , s : int ) -> int : \"\"\" renvoie le nombre minimal de pi\u00e8ces pour rendre la somme s en utilisant le jeu de pi\u00e8ces P\"\"\" if s == 0 : return 0 else : mini = float ( 'inf' ) # On fixe le nombre de pi\u00e8ce \u00e0 l'infini for i in range ( len ( P )): if ... <= s : nb = 1 + ... if nb < mini : mini = nb return mini P = ( 2 , 5 , 10 , 100 ) print ( rendu_monnaie_rec ( P , 17 )) Le programme devant renvoyer 3. Passage en programmation dynamique # On constate dans la partie pr\u00e9c\u00e9dente que la m\u00e9thode pr\u00e9c\u00e9dente fait de trop nombreux appels r\u00e9cursifs, qui ralentissent consid\u00e9rablement le temps de calcul, voire plante le programme d\u00e8s que la taille maximale de la pile est d\u00e9pass\u00e9e. On va donc utiliser la programmation dynamique pour acc\u00e9l\u00e9rer la vitesse de traitement du probl\u00e8me. Exercice : Compl\u00e9ter la fonction suivante afin qu'elle renvoie le nombre minimal de pi\u00e8ce pour rendre la monnaie, ou None s'il est impossible de rendre la monnaie. Est-ce une m\u00e9thode ascendante ou descendante ? 1 2 3 4 5 6 7 8 def renduMonnaie1 ( P : list , s : int ) -> int | None : nb = [ 0 ] + [ None ] * ( s ) for n in range ( 1 , s + 1 ) : for p in P : if p <= ... and nb [ ... ] is not None : if nb [ n ] is ... or ... > 1 + nb [ n - p ]: nb [ n ] = 1 + nb [ n - p ] return ...","title":"Prog Dynamique"},{"location":"Terminale/prog_dyn/#programmation-dynamique","text":"","title":"Programmation dynamique"},{"location":"Terminale/prog_dyn/#contexte","text":"Exercice 1 : \u00c9crire une fonction r\u00e9cursive qui calcule la factorielle n. Rappel : \\(n!=1\\times 2\\times 3\\times ...\\times n\\) ` \u00c9crire une fonction r\u00e9cursive qui permet de calculer le \\(n^{i\u00e8me}\\) terme de la suite de Fibonacci. Donc pour n = 6, cette deuxi\u00e8me fonction peut se repr\u00e9senter par le sch\u00e9ma ci-dessous : arbre Vous pouvez constater que l'on a une structure arborescente (typique dans les algorithmes r\u00e9cursifs), si on additionne toutes les feuilles de cette structure arborescente (fib(1) = 1 et fib(0) = 0), on retrouve bien 8. En observant attentivement le sch\u00e9ma ci-dessus, vous avez remarqu\u00e9 que de nombreux calculs sont inutiles, car effectu\u00e9 2 fois : par exemple on retrouve le calcul de fib(4) \u00e0 2 endroits (en haut \u00e0 droite et un peu plus bas \u00e0 gauche) : arbre","title":"Contexte"},{"location":"Terminale/prog_dyn/#programmation-dynamique_1","text":"","title":"Programmation Dynamique"},{"location":"Terminale/prog_dyn/#premiers-exemples-sur-la-suite-de-fibonacci","text":"En consid\u00e9rant l'algorithme pr\u00e9c\u00e9dant, on comprend bien qu'il est particuli\u00e8rement inefficace de calculer plusieurs fois le m\u00eame sous-calcul. Afin d'am\u00e9liorer le temps de calcul de l'algorithme, nous d\u00e9cidons donc de m\u00e9moriser les calculs d\u00e9j\u00e0 effectu\u00e9s dans un tableau. Il existe deux m\u00e9thodes diff\u00e9rentes : Bottom-Up Top Down On pourrait donc grandement simplifier le calcul en calculant une fois pour toutes fib(4), en \"m\u00e9morisant\" le r\u00e9sultat et en le r\u00e9utilisant quand n\u00e9cessaire. On va calculer les nombres de la suite de Fibonacci jusqu'\u00e0 \\(F(n)\\) en partant de \\(F(0)\\) et \\(F(1)\\) . On appelle ce type de m\u00e9thode une m\u00e9thode Bottom-Up. Ce n'est pas une m\u00e9thode r\u00e9cursive. 1 2 3 4 5 6 def fibo_asc ( n : int ) -> int : F = [ 0 ] * ( n + 1 ) F [ 1 ] = 1 for i in range ( 2 , n + 1 ) : F [ i ] = F [ i - 1 ] + F [ i - 2 ] return F [ n ] On va calculer les nombres de Fibonacci r\u00e9cursivement, mais en sauvegardant les calculs d\u00e9j\u00e0 effectu\u00e9s dans une liste Python, en profitant de sa mutabilit\u00e9. On appelle ce type de m\u00e9thode une approche Top-Down : 1 2 3 4 5 6 7 8 def fibo_desc ( n : int ) -> int : memo = [ 0 , 1 ] + [ None ] * ( n - 1 ) def compute ( n , memo ) : if memo [ n ] is None : memo [ n ] = compute ( n - 1 , memo ) + compute ( n - 2 , memo ) return memo [ n ] return compute ( n , memo )","title":"Premiers exemples sur la suite de Fibonacci"},{"location":"Terminale/prog_dyn/#principes-de-la-programmation-dynamique","text":"La programmation dynamique, introduite au d\u00e9but des ann\u00e9es 1950 par Richard Bellman, est une m\u00e9thode pour r\u00e9soudre des probl\u00e8mes en combinant des solutions de sous-probl\u00e8mes, tout comme les m\u00e9thodes de type diviser pour r\u00e9gner. Un algorithme de programmation dynamique r\u00e9sout chaque sous-sous-probl\u00e8me une seule fois et m\u00e9morise sa r\u00e9ponse dans un tableau, \u00e9vitant ainsi le re-calcul de la solution chaque fois qu'il r\u00e9sout chaque sous-sous-probl\u00e8me. La programmation dynamique s'applique g\u00e9n\u00e9ralement aux probl\u00e8mes d'optimisation, comme ceux que nous avons vu l'an pass\u00e9 lorsque nous avons \u00e9tudi\u00e9 les algorithmes gloutons.","title":"Principes de la programmation dynamique"},{"location":"Terminale/prog_dyn/#application-aux-algorithmes-gloutons","text":"","title":"Application aux algorithmes gloutons"},{"location":"Terminale/prog_dyn/#rappels-pour-la-version-recursive","text":"Vous avez \u00e0 votre disposition un nombre illimit\u00e9 de pi\u00e8ces de 2, 5 cts, 10 cts, 50 cts et 1 euro (100 cts). Vous devez rendre une certaine somme (rendu de monnaie). Le probl\u00e8me est le suivant : \"Quel est le nombre minimum de pi\u00e8ces qui doivent \u00eatre utilis\u00e9es pour rendre la monnaie\" La r\u00e9solution \"gloutonne\" de ce probl\u00e8me peut \u00eatre la suivante : On prend la pi\u00e8ce qui a la plus grande valeur (il faut que la valeur de cette pi\u00e8ce soit inf\u00e9rieure ou \u00e9gale \u00e0 la somme restant \u00e0 rendre). On recommence l\u2019op\u00e9ration ci-dessus jusqu\u2019au moment o\u00f9 la somme \u00e0 rendre est \u00e9gale \u00e0 z\u00e9ro. Exemple : nous avons 1 euro 77 cts \u00e0 rendre : on utilise une pi\u00e8ce de 1 euro (plus grande valeur de pi\u00e8ce inf\u00e9rieure \u00e0 1,77 euro), il reste 77 cts \u00e0 rendre on utilise une pi\u00e8ce de 50 cts (plus grande valeur de pi\u00e8ce inf\u00e9rieure \u00e0 0,77 euro), il reste 27 cts \u00e0 rendre on utilise une pi\u00e8ce de 10 cts (plus grande valeur de pi\u00e8ce inf\u00e9rieure \u00e0 0,27 euro), il reste 17 cts \u00e0 rendre on utilise une pi\u00e8ce de 10 cts (plus grande valeur de pi\u00e8ce inf\u00e9rieure \u00e0 0,17 euro), il reste 7 cts \u00e0 rendre on utilise une pi\u00e8ce de 5 cts (plus grande valeur de pi\u00e8ce inf\u00e9rieure \u00e0 0,07 euro), il reste 2 cts \u00e0 rendre on utilise une pi\u00e8ce de 2 cts (plus grande valeur de pi\u00e8ce inf\u00e9rieure \u00e0 0,02 euro), il reste 0 cts \u00e0 rendre. L'algorithme se termine en renvoyant 6 (on a d\u00fb rendre 6 pi\u00e8ces) Exercice : Compl\u00e9ter la fonction suivante pour qu'elle donne le nombre minimal de pi\u00e8ces utilis\u00e9es pour une somme s donn\u00e9e : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def rendu_monnaie_rec ( P : list , s : int ) -> int : \"\"\" renvoie le nombre minimal de pi\u00e8ces pour rendre la somme s en utilisant le jeu de pi\u00e8ces P\"\"\" if s == 0 : return 0 else : mini = float ( 'inf' ) # On fixe le nombre de pi\u00e8ce \u00e0 l'infini for i in range ( len ( P )): if ... <= s : nb = 1 + ... if nb < mini : mini = nb return mini P = ( 2 , 5 , 10 , 100 ) print ( rendu_monnaie_rec ( P , 17 )) Le programme devant renvoyer 3.","title":"Rappels pour la version r\u00e9cursive"},{"location":"Terminale/prog_dyn/#passage-en-programmation-dynamique","text":"On constate dans la partie pr\u00e9c\u00e9dente que la m\u00e9thode pr\u00e9c\u00e9dente fait de trop nombreux appels r\u00e9cursifs, qui ralentissent consid\u00e9rablement le temps de calcul, voire plante le programme d\u00e8s que la taille maximale de la pile est d\u00e9pass\u00e9e. On va donc utiliser la programmation dynamique pour acc\u00e9l\u00e9rer la vitesse de traitement du probl\u00e8me. Exercice : Compl\u00e9ter la fonction suivante afin qu'elle renvoie le nombre minimal de pi\u00e8ce pour rendre la monnaie, ou None s'il est impossible de rendre la monnaie. Est-ce une m\u00e9thode ascendante ou descendante ? 1 2 3 4 5 6 7 8 def renduMonnaie1 ( P : list , s : int ) -> int | None : nb = [ 0 ] + [ None ] * ( s ) for n in range ( 1 , s + 1 ) : for p in P : if p <= ... and nb [ ... ] is not None : if nb [ n ] is ... or ... > 1 + nb [ n - p ]: nb [ n ] = 1 + nb [ n - p ] return ...","title":"Passage en programmation dynamique"},{"location":"Terminale/R%C3%A9cursivit%C3%A9/exos_Bac_rec/","text":"Fiche d'exercices type Bac # Exercice 1 # D'apr\u00e8s 2021, M\u00e9tropole, Candidats libres, J2, Ex. 4 D'apr\u00e8s 2021, M\u00e9tropole, Candidats libres, J2, Ex. 4 On s'int\u00e9resse dans cet exercice \u00e0 un algorithme de m\u00e9lange des \u00e9l\u00e9ments d'une liste. 1. Pour la suite, il sera utile de disposer d'une fonction echange qui permet d'\u00e9changer dans une liste valeurs les \u00e9l\u00e9ments d'indice i et j . Expliquer pourquoi le code Python ci-dessous ne r\u00e9alise pas cet \u00e9change et en proposer une modification. def echange ( valeurs , i , j ): valeurs [ j ] = valeurs [ i ] valeurs [ i ] = valeurs [ j ] 2. La documentation du module random de Python fournit les informations ci-dessous concernant la fonction randint : randint(a, b) Renvoie un entier al\u00e9atoire N tel que a <= N <= b . Alias pour randrange(a, b + 1) . Parmi les valeurs ci-dessous, quelles sont celles qui peuvent \u00eatre renvoy\u00e9es par l'appel randint(0, 10) ? 0 1 3.5 9 10 11 3. Le m\u00e9lange de Fischer-Yates est un algorithme permettant de permuter al\u00e9atoirement les \u00e9l\u00e9ments d'une liste. On donne ci-dessous une mise en \u0153uvre r\u00e9cursive de cet algorithme en Python. 1 2 3 4 5 6 7 8 from random import randint def melange ( valeurs , i ): print ( valeurs ) if i > 0 : j = randint ( 0 , i ) echange ( valeurs , i , j ) melange ( valeurs , i - 1 ) 3.a. Expliquer pourquoi la fonction melange se termine toujours. 3.b. Lors de l'appel de la fonction melange , la valeur du param\u00e8tre i doit \u00eatre \u00e9gal au plus grand indice possible de la liste valeurs . Pour une liste de longueur \\(n\\) , quel est le nombre d'appels r\u00e9cursifs de la fonction melange effectu\u00e9s, sans compter l'appel initial ? 3.c. On consid\u00e8re le script ci-dessous : valeurs = [ x for x in range ( 5 )] melange ( valeurs , 4 ) On suppose que les valeurs successivement renvoy\u00e9es par la fonction randint sont 2 , 1 , 2 et 0 . Les deux premiers affichages produits par l'instruction print ( valeurs ) de la fonction melange sont : Premier affichage : [ 0 , 1 , 2 , 3 , 4 ] , Deuxi\u00e8me affichage : [ 0 , 1 , 4 , 3 , 2 ] . Donner les affichages suivants produits par la fonction melange ? 3.d. Proposer une version it\u00e9rative du m\u00e9lange de Fischer-Yates. Exercice 2 # Cet exercice traite du th\u00e8me \u00abprogrammation\u00bb, et principalement de la r\u00e9cursivit\u00e9. On rappelle qu'une cha\u00eene de caract\u00e8res peut \u00eatre repr\u00e9sent\u00e9e en Python par un texte entre guillemets \"\" et que : la fonction `len`` renvoie la longueur de la cha\u00eene de caract\u00e8res pass\u00e9e en param\u00e8tre ; si une variable ch d\u00e9signe une cha\u00eene de caract\u00e8res, alors ch[0]`` renvoie son premier caract\u00e8re, ch[1]`` le deuxi\u00e8me, etc. ; l'op\u00e9rateur `+`` permet de concat\u00e9ner deux cha\u00eenes de caract\u00e8res. Exemples : >>> texte = \"bricot\" >>> len ( texte ) 6 >>> texte [ 0 ] \"b\" >>> texte [ 1 ] \"r\" >>> \"a\" + texte \"abricot\" On s'int\u00e9resse dans cet exercice \u00e0 la construction de cha\u00eenes de caract\u00e8res suivant certaines r\u00e8gles de construction. R\u00e8gle A : une cha\u00eene est construite suivant la r\u00e8gle A dans les deux cas suivants: soit elle est \u00e9gale \u00e0 \"a\" ; soit elle est de la forme \"a\" + chaine + \"a\", o\u00f9 chaine est une cha\u00eene de caract\u00e8res construite suivant la r\u00e8gle A. R\u00e8gle B : une cha\u00eene est construite suivant la r\u00e8gle B dans les deux cas suivants : soit elle est de la forme \"b\"+chaine+\"b\", o\u00f9 chaine est une cha\u00eene de caract\u00e8res construite suivant la r\u00e8gle A ; soit elle est de la forme \"b\" + chaine+\"b\", o\u00f9 chaine est une cha\u00eene de caract\u00e8res construite suivant la r\u00e8gle B. On a reproduit ci-dessous l'aide de la fonction choice du module random. >>> from random import choice >>> help ( choice ) Help on method choice in module random : choice ( seq ) method of random . Random instance Choose a random element from a non - empty sequence . La fonction A() ci-dessous renvoie une cha\u00eene de caract\u00e8res construite suivant la r\u00e8gle A, en choisissant al\u00e9atoirement entre les deux cas de figure de cette r\u00e8gle. def A (): if choice ([ True , False ]): return \"a\" else : return \"a\" + A () + \"a\" 1.a Cette fonction est-elle r\u00e9cursive ? Justifier. 1.b La fonction `choice([True, False])`` peut renvoyer False un tr\u00e8s grand nombre de fois cons\u00e9cutives. Expliquer pourquoi ce cas de figure am\u00e8nerait \u00e0 une erreur d'ex\u00e9cution. Dans la suite, on consid\u00e8re une deuxi\u00e8me version de la fonction A. \u00c0 pr\u00e9sent, la fonction prend en param\u00e8tre un entier n tel que, si la valeur de n est n\u00e9gative ou nulle, la fonction renvoie \"a\". Si la valeur de n est strictement positive, elle renvoie une cha\u00eene de caract\u00e8res construite suivant la r\u00e8gle A avec un n d\u00e9cr\u00e9ment\u00e9 de 1, en choisissant al\u00e9atoirement entre les deux cas de figure de cette r\u00e8gle. def A ( n ): if ... or choice ([ True , False ]) : return \"a\" else : return \"a\" + ... + \"a\" 2.a. Recopier sur code la copie et compl\u00e9ter aux emplacements des points de suspension ... le code de cette nouvelle fonction A. 2.b. Justifier le fait qu'un appel de la forme A(n) avec n un nombre entier positif inf\u00e9rieur \u00e0 50, termine toujours. On donne ci-apr\u00e8s le code de la fonction r\u00e9cursive B qui prend en param\u00e8tre un entier \\(n\\) et qui renvoie une cha\u00eene de caract\u00e8res construite suivant la r\u00e8gle B. def B ( n ): if n <= 0 or choice ([ True , False ]): return \"b\" + A ( n - 1 ) + \"b\" else : return \"b\" + B ( n - 1 ) + \"b\" On admet que : les appels A(-1) et A(0) renvoient la cha\u00eene \"a\"; l\u2019appel A(1) renvoie la cha\u00eene \"a\" ou la cha\u00eene \"aaa\"; l\u2019appel A(2) renvoie la cha\u00eene \"a\", la cha\u00eene \"aaa\" ou la cha\u00eene \"aaaaa\". 3. Donner toutes les cha\u00eenes possibles renvoy\u00e9es par les appels B(0), B(1) et B(2). On suppose maintenant qu'on dispose d'une fonction raccourcir qui prend comme param\u00e8tre une cha\u00eene de caract\u00e8res de longueur sup\u00e9rieure ou \u00e9gale \u00e0 2, et renvoie la cha\u00eene de caract\u00e8res obtenue \u00e0 partir de la cha\u00eene initiale en lui \u00f4tant le premier et le dernier caract\u00e8re. Exemple : >>> raccourcir ( \"abricot\" ) \"brico\" >>> raccourcir ( \"ab\" ) \"\" 4.a. Recopier sur la copie et compl\u00e9ter les points de suspension ... du code de la fonction regleA ci-dessous pour qu'elle renvoie True si la cha\u00eene pass\u00e9e en param\u00e8tre est construite suivant la r\u00e8gle A, et False sinon. def regleA ( chaine ): n = len ( chaine ) if n >= 2 : return chaine [ 0 ] == \"a\" and chaine [ n - 1 ] == \"a\" and regleA ( ... ) else : return chaine == ... 4.b. \u00c9crire le code d\u2019une fonction regleB , prenant en param\u00e8tre une cha\u00eene de caract\u00e8res et renvoyant True si la cha\u00eene est construite suivant la r\u00e8gle B,et False sinon.","title":"Exercices"},{"location":"Terminale/R%C3%A9cursivit%C3%A9/exos_Bac_rec/#fiche-dexercices-type-bac","text":"","title":"Fiche d'exercices type Bac"},{"location":"Terminale/R%C3%A9cursivit%C3%A9/exos_Bac_rec/#exercice-1","text":"D'apr\u00e8s 2021, M\u00e9tropole, Candidats libres, J2, Ex. 4 D'apr\u00e8s 2021, M\u00e9tropole, Candidats libres, J2, Ex. 4 On s'int\u00e9resse dans cet exercice \u00e0 un algorithme de m\u00e9lange des \u00e9l\u00e9ments d'une liste. 1. Pour la suite, il sera utile de disposer d'une fonction echange qui permet d'\u00e9changer dans une liste valeurs les \u00e9l\u00e9ments d'indice i et j . Expliquer pourquoi le code Python ci-dessous ne r\u00e9alise pas cet \u00e9change et en proposer une modification. def echange ( valeurs , i , j ): valeurs [ j ] = valeurs [ i ] valeurs [ i ] = valeurs [ j ] 2. La documentation du module random de Python fournit les informations ci-dessous concernant la fonction randint : randint(a, b) Renvoie un entier al\u00e9atoire N tel que a <= N <= b . Alias pour randrange(a, b + 1) . Parmi les valeurs ci-dessous, quelles sont celles qui peuvent \u00eatre renvoy\u00e9es par l'appel randint(0, 10) ? 0 1 3.5 9 10 11 3. Le m\u00e9lange de Fischer-Yates est un algorithme permettant de permuter al\u00e9atoirement les \u00e9l\u00e9ments d'une liste. On donne ci-dessous une mise en \u0153uvre r\u00e9cursive de cet algorithme en Python. 1 2 3 4 5 6 7 8 from random import randint def melange ( valeurs , i ): print ( valeurs ) if i > 0 : j = randint ( 0 , i ) echange ( valeurs , i , j ) melange ( valeurs , i - 1 ) 3.a. Expliquer pourquoi la fonction melange se termine toujours. 3.b. Lors de l'appel de la fonction melange , la valeur du param\u00e8tre i doit \u00eatre \u00e9gal au plus grand indice possible de la liste valeurs . Pour une liste de longueur \\(n\\) , quel est le nombre d'appels r\u00e9cursifs de la fonction melange effectu\u00e9s, sans compter l'appel initial ? 3.c. On consid\u00e8re le script ci-dessous : valeurs = [ x for x in range ( 5 )] melange ( valeurs , 4 ) On suppose que les valeurs successivement renvoy\u00e9es par la fonction randint sont 2 , 1 , 2 et 0 . Les deux premiers affichages produits par l'instruction print ( valeurs ) de la fonction melange sont : Premier affichage : [ 0 , 1 , 2 , 3 , 4 ] , Deuxi\u00e8me affichage : [ 0 , 1 , 4 , 3 , 2 ] . Donner les affichages suivants produits par la fonction melange ? 3.d. Proposer une version it\u00e9rative du m\u00e9lange de Fischer-Yates.","title":"Exercice 1"},{"location":"Terminale/R%C3%A9cursivit%C3%A9/exos_Bac_rec/#exercice-2","text":"Cet exercice traite du th\u00e8me \u00abprogrammation\u00bb, et principalement de la r\u00e9cursivit\u00e9. On rappelle qu'une cha\u00eene de caract\u00e8res peut \u00eatre repr\u00e9sent\u00e9e en Python par un texte entre guillemets \"\" et que : la fonction `len`` renvoie la longueur de la cha\u00eene de caract\u00e8res pass\u00e9e en param\u00e8tre ; si une variable ch d\u00e9signe une cha\u00eene de caract\u00e8res, alors ch[0]`` renvoie son premier caract\u00e8re, ch[1]`` le deuxi\u00e8me, etc. ; l'op\u00e9rateur `+`` permet de concat\u00e9ner deux cha\u00eenes de caract\u00e8res. Exemples : >>> texte = \"bricot\" >>> len ( texte ) 6 >>> texte [ 0 ] \"b\" >>> texte [ 1 ] \"r\" >>> \"a\" + texte \"abricot\" On s'int\u00e9resse dans cet exercice \u00e0 la construction de cha\u00eenes de caract\u00e8res suivant certaines r\u00e8gles de construction. R\u00e8gle A : une cha\u00eene est construite suivant la r\u00e8gle A dans les deux cas suivants: soit elle est \u00e9gale \u00e0 \"a\" ; soit elle est de la forme \"a\" + chaine + \"a\", o\u00f9 chaine est une cha\u00eene de caract\u00e8res construite suivant la r\u00e8gle A. R\u00e8gle B : une cha\u00eene est construite suivant la r\u00e8gle B dans les deux cas suivants : soit elle est de la forme \"b\"+chaine+\"b\", o\u00f9 chaine est une cha\u00eene de caract\u00e8res construite suivant la r\u00e8gle A ; soit elle est de la forme \"b\" + chaine+\"b\", o\u00f9 chaine est une cha\u00eene de caract\u00e8res construite suivant la r\u00e8gle B. On a reproduit ci-dessous l'aide de la fonction choice du module random. >>> from random import choice >>> help ( choice ) Help on method choice in module random : choice ( seq ) method of random . Random instance Choose a random element from a non - empty sequence . La fonction A() ci-dessous renvoie une cha\u00eene de caract\u00e8res construite suivant la r\u00e8gle A, en choisissant al\u00e9atoirement entre les deux cas de figure de cette r\u00e8gle. def A (): if choice ([ True , False ]): return \"a\" else : return \"a\" + A () + \"a\" 1.a Cette fonction est-elle r\u00e9cursive ? Justifier. 1.b La fonction `choice([True, False])`` peut renvoyer False un tr\u00e8s grand nombre de fois cons\u00e9cutives. Expliquer pourquoi ce cas de figure am\u00e8nerait \u00e0 une erreur d'ex\u00e9cution. Dans la suite, on consid\u00e8re une deuxi\u00e8me version de la fonction A. \u00c0 pr\u00e9sent, la fonction prend en param\u00e8tre un entier n tel que, si la valeur de n est n\u00e9gative ou nulle, la fonction renvoie \"a\". Si la valeur de n est strictement positive, elle renvoie une cha\u00eene de caract\u00e8res construite suivant la r\u00e8gle A avec un n d\u00e9cr\u00e9ment\u00e9 de 1, en choisissant al\u00e9atoirement entre les deux cas de figure de cette r\u00e8gle. def A ( n ): if ... or choice ([ True , False ]) : return \"a\" else : return \"a\" + ... + \"a\" 2.a. Recopier sur code la copie et compl\u00e9ter aux emplacements des points de suspension ... le code de cette nouvelle fonction A. 2.b. Justifier le fait qu'un appel de la forme A(n) avec n un nombre entier positif inf\u00e9rieur \u00e0 50, termine toujours. On donne ci-apr\u00e8s le code de la fonction r\u00e9cursive B qui prend en param\u00e8tre un entier \\(n\\) et qui renvoie une cha\u00eene de caract\u00e8res construite suivant la r\u00e8gle B. def B ( n ): if n <= 0 or choice ([ True , False ]): return \"b\" + A ( n - 1 ) + \"b\" else : return \"b\" + B ( n - 1 ) + \"b\" On admet que : les appels A(-1) et A(0) renvoient la cha\u00eene \"a\"; l\u2019appel A(1) renvoie la cha\u00eene \"a\" ou la cha\u00eene \"aaa\"; l\u2019appel A(2) renvoie la cha\u00eene \"a\", la cha\u00eene \"aaa\" ou la cha\u00eene \"aaaaa\". 3. Donner toutes les cha\u00eenes possibles renvoy\u00e9es par les appels B(0), B(1) et B(2). On suppose maintenant qu'on dispose d'une fonction raccourcir qui prend comme param\u00e8tre une cha\u00eene de caract\u00e8res de longueur sup\u00e9rieure ou \u00e9gale \u00e0 2, et renvoie la cha\u00eene de caract\u00e8res obtenue \u00e0 partir de la cha\u00eene initiale en lui \u00f4tant le premier et le dernier caract\u00e8re. Exemple : >>> raccourcir ( \"abricot\" ) \"brico\" >>> raccourcir ( \"ab\" ) \"\" 4.a. Recopier sur la copie et compl\u00e9ter les points de suspension ... du code de la fonction regleA ci-dessous pour qu'elle renvoie True si la cha\u00eene pass\u00e9e en param\u00e8tre est construite suivant la r\u00e8gle A, et False sinon. def regleA ( chaine ): n = len ( chaine ) if n >= 2 : return chaine [ 0 ] == \"a\" and chaine [ n - 1 ] == \"a\" and regleA ( ... ) else : return chaine == ... 4.b. \u00c9crire le code d\u2019une fonction regleB , prenant en param\u00e8tre une cha\u00eene de caract\u00e8res et renvoyant True si la cha\u00eene est construite suivant la r\u00e8gle B,et False sinon.","title":"Exercice 2"},{"location":"Terminale/R%C3%A9cursivit%C3%A9/exos_correc_Bac_rec/","text":"Fiche d'exercices type Bac # Exercice 2 # D'apr\u00e8s 2021, M\u00e9tropole, Candidats libres, J2, Ex. 4 On s'int\u00e9resse dans cet exercice \u00e0 un algorithme de m\u00e9lange des \u00e9l\u00e9ments d'une liste. Pour la suite, il sera utile de disposer d'une fonction echange qui permet d'\u00e9changer dans une liste valeurs les \u00e9l\u00e9ments d'indice i et j. Expliquer pourquoi le code Python ci-dessous ne r\u00e9alise pas cet \u00e9change et en proposer une modification. def echange ( valeurs , i , j ): valeurs [ j ] = valeurs [ i ] valeurs [ i ] = valeurs [ j ] R\u00e9ponse On perd la valeur initiale de list[j] d\u00e8s la premi\u00e8re instruction. On peut proc\u00e9der de deux fa\u00e7ons diff\u00e9rentes : Avec une variable temporaire : def echange ( valeurs , i , j ): temp = valeurs [ j ] valeurs [ j ] = valeurs [ i ] valeurs [ i ] = temp En utilisant l'affectation multiple : def echange ( valeurs , i , j ): valeurs [ i ], valeurs [ j ] = valeurs [ j ], valeurs [ i ] 2. La documentation du module random de Python fournit les informations ci-dessous concernant la fonction randint : randint(a, b) Renvoie un entier al\u00e9atoire N tel que a <= N <= b . Alias pour randrange(a, b + 1) . Parmi les valeurs ci-dessous, quelles sont celles qui peuvent \u00eatre renvoy\u00e9es par l'appel randint(0, 10) ? 0 1 3.5 9 10 11 R\u00e9ponse L'appel randint(0, 10) renvoie une valeur enti\u00e8re entre 0 et 10 inclus l'un et l'autres. Donc 0 , 1 , 9 et 10 sont des valeurs possibles. 3. Le m\u00e9lange de Fischer-Yates est un algorithme permettant de permuter al\u00e9atoirement les \u00e9l\u00e9ments d'une liste. On donne ci-dessous une mise en \u0153uvre r\u00e9cursive de cet algorithme en Python. 1 2 3 4 5 6 7 8 from random import randint def melange ( valeurs , i ): print ( valeurs ) if i > 0 : j = randint ( 0 , i ) echange ( valeurs , i , j ) melange ( valeurs , i - 1 ) 3.a. Expliquer pourquoi la fonction melange se termine toujours. R\u00e9ponse On suppose que i est un entier positif compris entre 0 et l'indice du dernier \u00e9l\u00e9ment de la liste ( len ( valeurs ) - 1 ). Lors des appels r\u00e9cursifs, on d\u00e9cr\u00e9mente la valeur de i et ces appels n'ont lieu que si cette valeur est strictement positive. Donc la fonction s'arr\u00eatera toujours. 3.b. Lors de l'appel de la fonction melange , la valeur du param\u00e8tre i doit \u00eatre \u00e9gal au plus grand indice possible de la liste valeurs . Pour une liste de longueur \\(n\\) , quel est le nombre d'appels r\u00e9cursifs de la fonction melange effectu\u00e9s, sans compter l'appel initial ? R\u00e9ponse Pour une liste de longueur \\(n\\) , on appelle tout d'abord melange(valeurs, n - 1) . Le premier appel r\u00e9cursif est donc melange(valeurs, i - 2) . Il est suivi d'appels r\u00e9cursifs correspondants aux diff\u00e9rents indices de valeurs jusqu'au dernier appel melange(valeurs, 0) . Donc il y a \\(n-1\\) appels r\u00e9cursifs. 3.c. On consid\u00e8re le script ci-dessous : valeurs = [ x for x in range ( 5 )] melange ( valeurs , 4 ) On suppose que les valeurs successivement renvoy\u00e9es par la fonction randint sont 2 , 1 , 2 et 0 . Les deux premiers affichages produits par l'instruction print ( valeurs ) de la fonction melange sont : Premier affichage : [ 0 , 1 , 2 , 3 , 4 ] , Deuxi\u00e8me affichage : [ 0 , 1 , 4 , 3 , 2 ] . Donner les affichages suivants produits par la fonction melange . R\u00e9ponse On a les \u00e9tapes suivantes : Valeur de ind Valeur de valeurs affich\u00e9e Valeur renvoy\u00e9e par randint ind = 4 [0, 1, 2, 3, 4] 2 ind = 3 [0, 1, 4, 3, 2] 1 ind = 2 [0, 3, 4, 1, 2] 2 ind = 1 [0, 3, 4, 1, 2] 0 ind = 0 [3, 0, 4, 1, 2] 3.d. Proposer une version it\u00e9rative du m\u00e9lange de Fischer-Yates. R\u00e9ponse from random import randint def melange ( valeurs ): indice_dernier = len ( valeurs ) - 1 for i in range ( indice_dernier , 0 , - 1 ): j = randint ( 0 , i ) echange ( valeurs , i , j ) Exercice 2 # Cet exercice traite du th\u00e8me \u00abprogrammation\u00bb, et principalement de la r\u00e9cursivit\u00e9. On rappelle qu'une cha\u00eene de caract\u00e8res peut \u00eatre repr\u00e9sent\u00e9e en Python par un texte entre guillemets \"\" et que : la fonction len renvoie la longueur de la cha\u00eene de caract\u00e8res pass\u00e9e en param\u00e8tre ; si une variable ch d\u00e9signe une cha\u00eene de caract\u00e8res, alors ch[0] renvoie son premier caract\u00e8re, ch[1] le deuxi\u00e8me, etc. ; l'op\u00e9rateur `+`` permet de concat\u00e9ner deux cha\u00eenes de caract\u00e8res. Exemples : >>> texte = \"bricot\" >>> len ( texte ) 6 >>> texte [ 0 ] \"b\" >>> texte [ 1 ] \"r\" >>> \"a\" + texte \"abricot\" On s'int\u00e9resse dans cet exercice \u00e0 la construction de cha\u00eenes de caract\u00e8res suivant certaines r\u00e8gles de construction. R\u00e8gle A : une cha\u00eene est construite suivant la r\u00e8gle A dans les deux cas suivants: soit elle est \u00e9gale \u00e0 \"a\" ; soit elle est de la forme \"a\" + chaine + \"a\", o\u00f9 chaine est une cha\u00eene de caract\u00e8res construite suivant la r\u00e8gle A. R\u00e8gle B : une cha\u00eene est construite suivant la r\u00e8gle B dans les deux cas suivants : soit elle est de la forme \"b\"+chaine+\"b\", o\u00f9 chaine est une cha\u00eene de caract\u00e8res construite suivant la r\u00e8gle A ; soit elle est de la forme \"b\" + chaine+\"b\", o\u00f9 chaine est une cha\u00eene de caract\u00e8res construite suivant la r\u00e8gle B. On a reproduit ci-dessous l'aide de la fonction choice du module random. >>> from random import choice >>> help ( choice ) Help on method choice in module random : choice ( seq ) method of random . Random instance Choose a random element from a non - empty sequence . La fonction A() ci-dessous renvoie une cha\u00eene de caract\u00e8res construite suivant la r\u00e8gle A, en choisissant al\u00e9atoirement entre les deux cas de figure de cette r\u00e8gle. def A (): if choice ([ True , False ]): return \"a\" else : return \"a\" + A () + \"a\" 1.a. Cette fonction est-elle r\u00e9cursive ? Justifier. R\u00e9ponse La fonction A s\u2019appelle elle-m\u00eame, donc A est une fonction r\u00e9cursive. 1.b. La fonction choice([True, False]) peut renvoyer False un tr\u00e8s grand nombre de fois cons\u00e9cutives. Expliquer pourquoi ce cas de figure am\u00e8nerait \u00e0 une erreur d'ex\u00e9cution. R\u00e9ponse Le maximum de la profondeur de r\u00e9cursion en Python est g\u00e9n\u00e9ralement de 997, c\u2019est une protection contre un d\u00e9bordement de pile. On obtient alors cette erreur au del\u00e0 : RecursionError : maximum recursion depth exceeded in comparison Dans la suite, on consid\u00e8re une deuxi\u00e8me version de la fonction A. \u00c0 pr\u00e9sent, la fonction prend en param\u00e8tre un entier n tel que, si la valeur de n est n\u00e9gative ou nulle, la fonction renvoie \"a\". Si la valeur de n est strictement positive, elle renvoie une cha\u00eene de caract\u00e8res construite suivant la r\u00e8gle A avec un n d\u00e9cr\u00e9ment\u00e9 de 1, en choisissant al\u00e9atoirement entre les deux cas de figure de cette r\u00e8gle. def A ( n ): if ... or choice ([ True , False ]) : return \"a\" else : return \"a\" + ... + \"a\" 2.a. Recopier sur la copie et compl\u00e9ter aux emplacements des points de suspension ... le code de cette nouvelle fonction A. R\u00e9ponse ``` python def A(n): if n<=0 or choice([True, False]) : return \"a\" else: return \"a\" + A(n-1) + \"a\" ``` 2.b. Justifier le fait qu'un appel de la forme A(n) avec n un nombre entier positif inf\u00e9rieur \u00e0 50, termine toujours. R\u00e9ponse Pour n > 0, l\u2019appel \u00e0 A(n) provoque ou bien un arr\u00eat de la fonction si choice([True, False]) = True, ou bien un appel r\u00e9cursif A(n \u22121). Un appel \u00e0 A(50) pourrait provoquer dans le pire des cas 50 appels r\u00e9cursifs pour arriver \u00e0 A(0) qui termine, ou alors terminer avant! On donne ci-apr\u00e8s le code de la fonction r\u00e9cursive B qui prend en param\u00e8tre un entier n et qui renvoie une cha\u00eene de caract\u00e8res construite suivant la r\u00e8gle B. def B ( n ): if n <= 0 or choice ([ True , False ]): return \"b\" + A ( n - 1 ) + \"b\" else : return \"b\" + B ( n - 1 ) + \"b\" On admet que : \u2022 les appels A(-1)et A(0) renvoient la cha\u00eene \"a\"; \u2022 l\u2019appel A(1) renvoie la cha\u00eene \"a\" ou la cha\u00eene \"aaa\"; \u2022 l\u2019appel A(2) renvoie la cha\u00eene \"a\", la cha\u00eene \"aaa\" ou la cha\u00eene \"aaaaa\". 3. Donner toutes les cha\u00eenes possibles renvoy\u00e9es par les appels B(0), B(1) et B(2). R\u00e9ponse L\u2019appel B(0) renvoie \"bab\" L\u2019appel B(1) renvoie \"bab\" ou \"bbabb\". L\u2019appel B(2) renvoie \"bab\", \"baaab\", \"bbabb\" ou \"bbbabbb\". On suppose maintenant qu'on dispose d'une fonction raccourcir qui prend comme param\u00e8tre une cha\u00eene de caract\u00e8res de longueur sup\u00e9rieure ou \u00e9gale \u00e0 2, et renvoie la cha\u00eene de caract\u00e8res obtenue \u00e0 partir de la cha\u00eene initiale en lui \u00f4tant le premier et le dernier caract\u00e8re. Exemple : >>> raccourcir ( \"abricot\" ) \"brico\" >>> raccourcir ( \"ab\" ) \"\" 4.a. Recopier sur la copie et compl\u00e9ter les points de suspension ... du code de la fonction regleA ci-dessous pour qu'elle renvoie True si la cha\u00eene pass\u00e9e en param\u00e8tre est construite suivant la r\u00e8gle A, et False sinon. def regleA ( chaine ): n = len ( chaine ) if n >= 2 : return chaine [ 0 ] == \"a\" and chaine [ n - 1 ] == \"a\" and regleA ( ... ) else : return chaine == ... R\u00e9ponse def regleA ( chaine ): n = len ( chaine ) if n >= 2 : return chaine [ 0 ] == \"a\" and chaine [ n - 1 ] == \"a\" and regle A ( racourcir ( chaine )) else : return chaine == \"a\" ou regle A(chaine[1 : n \u22121]) 4.b. \u00c9crire le code d\u2019une fonction regleB , prenant en param\u00e8tre une cha\u00eene de caract\u00e8res et renvoyant True si la cha\u00eene est construite suivant la r\u00e8gle B,et False sinon. R\u00e9ponse def regleB ( chaine ): n = len ( chaine ) if n >= 2 : return chaine [ 0 ] == \"b\" and chaine [ n - 1 ] == \"b\" and ( regleA ( chaine [ 1 : n - 1 ]) or regleB ( chaine [ 1 : n - 1 ])) else : return False","title":"Correction"},{"location":"Terminale/R%C3%A9cursivit%C3%A9/exos_correc_Bac_rec/#fiche-dexercices-type-bac","text":"","title":"Fiche d'exercices type Bac"},{"location":"Terminale/R%C3%A9cursivit%C3%A9/exos_correc_Bac_rec/#exercice-2","text":"D'apr\u00e8s 2021, M\u00e9tropole, Candidats libres, J2, Ex. 4 On s'int\u00e9resse dans cet exercice \u00e0 un algorithme de m\u00e9lange des \u00e9l\u00e9ments d'une liste. Pour la suite, il sera utile de disposer d'une fonction echange qui permet d'\u00e9changer dans une liste valeurs les \u00e9l\u00e9ments d'indice i et j. Expliquer pourquoi le code Python ci-dessous ne r\u00e9alise pas cet \u00e9change et en proposer une modification. def echange ( valeurs , i , j ): valeurs [ j ] = valeurs [ i ] valeurs [ i ] = valeurs [ j ] R\u00e9ponse On perd la valeur initiale de list[j] d\u00e8s la premi\u00e8re instruction. On peut proc\u00e9der de deux fa\u00e7ons diff\u00e9rentes : Avec une variable temporaire : def echange ( valeurs , i , j ): temp = valeurs [ j ] valeurs [ j ] = valeurs [ i ] valeurs [ i ] = temp En utilisant l'affectation multiple : def echange ( valeurs , i , j ): valeurs [ i ], valeurs [ j ] = valeurs [ j ], valeurs [ i ] 2. La documentation du module random de Python fournit les informations ci-dessous concernant la fonction randint : randint(a, b) Renvoie un entier al\u00e9atoire N tel que a <= N <= b . Alias pour randrange(a, b + 1) . Parmi les valeurs ci-dessous, quelles sont celles qui peuvent \u00eatre renvoy\u00e9es par l'appel randint(0, 10) ? 0 1 3.5 9 10 11 R\u00e9ponse L'appel randint(0, 10) renvoie une valeur enti\u00e8re entre 0 et 10 inclus l'un et l'autres. Donc 0 , 1 , 9 et 10 sont des valeurs possibles. 3. Le m\u00e9lange de Fischer-Yates est un algorithme permettant de permuter al\u00e9atoirement les \u00e9l\u00e9ments d'une liste. On donne ci-dessous une mise en \u0153uvre r\u00e9cursive de cet algorithme en Python. 1 2 3 4 5 6 7 8 from random import randint def melange ( valeurs , i ): print ( valeurs ) if i > 0 : j = randint ( 0 , i ) echange ( valeurs , i , j ) melange ( valeurs , i - 1 ) 3.a. Expliquer pourquoi la fonction melange se termine toujours. R\u00e9ponse On suppose que i est un entier positif compris entre 0 et l'indice du dernier \u00e9l\u00e9ment de la liste ( len ( valeurs ) - 1 ). Lors des appels r\u00e9cursifs, on d\u00e9cr\u00e9mente la valeur de i et ces appels n'ont lieu que si cette valeur est strictement positive. Donc la fonction s'arr\u00eatera toujours. 3.b. Lors de l'appel de la fonction melange , la valeur du param\u00e8tre i doit \u00eatre \u00e9gal au plus grand indice possible de la liste valeurs . Pour une liste de longueur \\(n\\) , quel est le nombre d'appels r\u00e9cursifs de la fonction melange effectu\u00e9s, sans compter l'appel initial ? R\u00e9ponse Pour une liste de longueur \\(n\\) , on appelle tout d'abord melange(valeurs, n - 1) . Le premier appel r\u00e9cursif est donc melange(valeurs, i - 2) . Il est suivi d'appels r\u00e9cursifs correspondants aux diff\u00e9rents indices de valeurs jusqu'au dernier appel melange(valeurs, 0) . Donc il y a \\(n-1\\) appels r\u00e9cursifs. 3.c. On consid\u00e8re le script ci-dessous : valeurs = [ x for x in range ( 5 )] melange ( valeurs , 4 ) On suppose que les valeurs successivement renvoy\u00e9es par la fonction randint sont 2 , 1 , 2 et 0 . Les deux premiers affichages produits par l'instruction print ( valeurs ) de la fonction melange sont : Premier affichage : [ 0 , 1 , 2 , 3 , 4 ] , Deuxi\u00e8me affichage : [ 0 , 1 , 4 , 3 , 2 ] . Donner les affichages suivants produits par la fonction melange . R\u00e9ponse On a les \u00e9tapes suivantes : Valeur de ind Valeur de valeurs affich\u00e9e Valeur renvoy\u00e9e par randint ind = 4 [0, 1, 2, 3, 4] 2 ind = 3 [0, 1, 4, 3, 2] 1 ind = 2 [0, 3, 4, 1, 2] 2 ind = 1 [0, 3, 4, 1, 2] 0 ind = 0 [3, 0, 4, 1, 2] 3.d. Proposer une version it\u00e9rative du m\u00e9lange de Fischer-Yates. R\u00e9ponse from random import randint def melange ( valeurs ): indice_dernier = len ( valeurs ) - 1 for i in range ( indice_dernier , 0 , - 1 ): j = randint ( 0 , i ) echange ( valeurs , i , j )","title":"Exercice 2"},{"location":"Terminale/R%C3%A9cursivit%C3%A9/exos_correc_Bac_rec/#exercice-2_1","text":"Cet exercice traite du th\u00e8me \u00abprogrammation\u00bb, et principalement de la r\u00e9cursivit\u00e9. On rappelle qu'une cha\u00eene de caract\u00e8res peut \u00eatre repr\u00e9sent\u00e9e en Python par un texte entre guillemets \"\" et que : la fonction len renvoie la longueur de la cha\u00eene de caract\u00e8res pass\u00e9e en param\u00e8tre ; si une variable ch d\u00e9signe une cha\u00eene de caract\u00e8res, alors ch[0] renvoie son premier caract\u00e8re, ch[1] le deuxi\u00e8me, etc. ; l'op\u00e9rateur `+`` permet de concat\u00e9ner deux cha\u00eenes de caract\u00e8res. Exemples : >>> texte = \"bricot\" >>> len ( texte ) 6 >>> texte [ 0 ] \"b\" >>> texte [ 1 ] \"r\" >>> \"a\" + texte \"abricot\" On s'int\u00e9resse dans cet exercice \u00e0 la construction de cha\u00eenes de caract\u00e8res suivant certaines r\u00e8gles de construction. R\u00e8gle A : une cha\u00eene est construite suivant la r\u00e8gle A dans les deux cas suivants: soit elle est \u00e9gale \u00e0 \"a\" ; soit elle est de la forme \"a\" + chaine + \"a\", o\u00f9 chaine est une cha\u00eene de caract\u00e8res construite suivant la r\u00e8gle A. R\u00e8gle B : une cha\u00eene est construite suivant la r\u00e8gle B dans les deux cas suivants : soit elle est de la forme \"b\"+chaine+\"b\", o\u00f9 chaine est une cha\u00eene de caract\u00e8res construite suivant la r\u00e8gle A ; soit elle est de la forme \"b\" + chaine+\"b\", o\u00f9 chaine est une cha\u00eene de caract\u00e8res construite suivant la r\u00e8gle B. On a reproduit ci-dessous l'aide de la fonction choice du module random. >>> from random import choice >>> help ( choice ) Help on method choice in module random : choice ( seq ) method of random . Random instance Choose a random element from a non - empty sequence . La fonction A() ci-dessous renvoie une cha\u00eene de caract\u00e8res construite suivant la r\u00e8gle A, en choisissant al\u00e9atoirement entre les deux cas de figure de cette r\u00e8gle. def A (): if choice ([ True , False ]): return \"a\" else : return \"a\" + A () + \"a\" 1.a. Cette fonction est-elle r\u00e9cursive ? Justifier. R\u00e9ponse La fonction A s\u2019appelle elle-m\u00eame, donc A est une fonction r\u00e9cursive. 1.b. La fonction choice([True, False]) peut renvoyer False un tr\u00e8s grand nombre de fois cons\u00e9cutives. Expliquer pourquoi ce cas de figure am\u00e8nerait \u00e0 une erreur d'ex\u00e9cution. R\u00e9ponse Le maximum de la profondeur de r\u00e9cursion en Python est g\u00e9n\u00e9ralement de 997, c\u2019est une protection contre un d\u00e9bordement de pile. On obtient alors cette erreur au del\u00e0 : RecursionError : maximum recursion depth exceeded in comparison Dans la suite, on consid\u00e8re une deuxi\u00e8me version de la fonction A. \u00c0 pr\u00e9sent, la fonction prend en param\u00e8tre un entier n tel que, si la valeur de n est n\u00e9gative ou nulle, la fonction renvoie \"a\". Si la valeur de n est strictement positive, elle renvoie une cha\u00eene de caract\u00e8res construite suivant la r\u00e8gle A avec un n d\u00e9cr\u00e9ment\u00e9 de 1, en choisissant al\u00e9atoirement entre les deux cas de figure de cette r\u00e8gle. def A ( n ): if ... or choice ([ True , False ]) : return \"a\" else : return \"a\" + ... + \"a\" 2.a. Recopier sur la copie et compl\u00e9ter aux emplacements des points de suspension ... le code de cette nouvelle fonction A. R\u00e9ponse ``` python def A(n): if n<=0 or choice([True, False]) : return \"a\" else: return \"a\" + A(n-1) + \"a\" ``` 2.b. Justifier le fait qu'un appel de la forme A(n) avec n un nombre entier positif inf\u00e9rieur \u00e0 50, termine toujours. R\u00e9ponse Pour n > 0, l\u2019appel \u00e0 A(n) provoque ou bien un arr\u00eat de la fonction si choice([True, False]) = True, ou bien un appel r\u00e9cursif A(n \u22121). Un appel \u00e0 A(50) pourrait provoquer dans le pire des cas 50 appels r\u00e9cursifs pour arriver \u00e0 A(0) qui termine, ou alors terminer avant! On donne ci-apr\u00e8s le code de la fonction r\u00e9cursive B qui prend en param\u00e8tre un entier n et qui renvoie une cha\u00eene de caract\u00e8res construite suivant la r\u00e8gle B. def B ( n ): if n <= 0 or choice ([ True , False ]): return \"b\" + A ( n - 1 ) + \"b\" else : return \"b\" + B ( n - 1 ) + \"b\" On admet que : \u2022 les appels A(-1)et A(0) renvoient la cha\u00eene \"a\"; \u2022 l\u2019appel A(1) renvoie la cha\u00eene \"a\" ou la cha\u00eene \"aaa\"; \u2022 l\u2019appel A(2) renvoie la cha\u00eene \"a\", la cha\u00eene \"aaa\" ou la cha\u00eene \"aaaaa\". 3. Donner toutes les cha\u00eenes possibles renvoy\u00e9es par les appels B(0), B(1) et B(2). R\u00e9ponse L\u2019appel B(0) renvoie \"bab\" L\u2019appel B(1) renvoie \"bab\" ou \"bbabb\". L\u2019appel B(2) renvoie \"bab\", \"baaab\", \"bbabb\" ou \"bbbabbb\". On suppose maintenant qu'on dispose d'une fonction raccourcir qui prend comme param\u00e8tre une cha\u00eene de caract\u00e8res de longueur sup\u00e9rieure ou \u00e9gale \u00e0 2, et renvoie la cha\u00eene de caract\u00e8res obtenue \u00e0 partir de la cha\u00eene initiale en lui \u00f4tant le premier et le dernier caract\u00e8re. Exemple : >>> raccourcir ( \"abricot\" ) \"brico\" >>> raccourcir ( \"ab\" ) \"\" 4.a. Recopier sur la copie et compl\u00e9ter les points de suspension ... du code de la fonction regleA ci-dessous pour qu'elle renvoie True si la cha\u00eene pass\u00e9e en param\u00e8tre est construite suivant la r\u00e8gle A, et False sinon. def regleA ( chaine ): n = len ( chaine ) if n >= 2 : return chaine [ 0 ] == \"a\" and chaine [ n - 1 ] == \"a\" and regleA ( ... ) else : return chaine == ... R\u00e9ponse def regleA ( chaine ): n = len ( chaine ) if n >= 2 : return chaine [ 0 ] == \"a\" and chaine [ n - 1 ] == \"a\" and regle A ( racourcir ( chaine )) else : return chaine == \"a\" ou regle A(chaine[1 : n \u22121]) 4.b. \u00c9crire le code d\u2019une fonction regleB , prenant en param\u00e8tre une cha\u00eene de caract\u00e8res et renvoyant True si la cha\u00eene est construite suivant la r\u00e8gle B,et False sinon. R\u00e9ponse def regleB ( chaine ): n = len ( chaine ) if n >= 2 : return chaine [ 0 ] == \"b\" and chaine [ n - 1 ] == \"b\" and ( regleA ( chaine [ 1 : n - 1 ]) or regleB ( chaine [ 1 : n - 1 ])) else : return False","title":"Exercice 2"},{"location":"Terminale/R%C3%A9cursivit%C3%A9/recursivite/","text":"R\u00e9cursivit\u00e9 # Contexte : la somme des premiers entiers # Pour d\u00e9finir la somme des \\(n\\) premiers entiers, on a l'habitude de d'\u00e9crire la formule suivante : \\[ 0 + 1 + 2 + 3 + .... + n \\] Cette formulation peut nous appara\u00eetre simple et intuitive. Exercice : \u00c9crire une fonction somme(n) qui retourne la somme des \\(n\\) premiers entiers. Or ce code n'est pas directement li\u00e9 \u00e0 la formule pr\u00e9c\u00e9dente. En effet, il n'y a rien dans cette formule qui laisse penser qu'il faille une variable interm\u00e9diaire pour calculer cette somme. C'est pourquoi, nous allons tenter de d\u00e9finir autrement cette fonction : \\[ somme(n)= \\left \\{ \\begin{array}{l l l} 0 & si &n=0 \\\\ n+somme(n-1) & si & n>0 \\end{array} \\right . \\] Cette d\u00e9finition nous indique ce que vaut somme ( n ) pour un entier \\(n\\) quelconque, selon que \\(n\\) soit \u00e9gal \u00e0 0 ou strictement positif. Ainsi, pour, pour le cas o\u00f9 \\(n\\) =0, la valeur de somme(n) vaut 0, et dans le cas o\u00f9 \\(n\\) est strictement positif, la valeur de somme(n) est \\(n+somme(n-1)\\) . Par exemple, voici ci-dessous les valeurs de 'somme(n)', pour \\(n\\) valant 0,1,2 et 3. \\[ \\begin{array}{l } somme(0)=0 \\\\ somme(1)=1+somme(0)=1+0=1 \\\\ somme(2)=2+somme(1)=2+1=3 \\end{array} \\] L'int\u00e9r\u00eat de cette formulation est qu'elle est directement programmable. En python, cela donne le programme ci-dessous. somme_rec.py 1 2 3 4 5 def somme ( n : int ) -> int : if n == 0 : return 0 else : return n + somme ( n - 1 ) R\u00e9cursivit\u00e9 # D\u00e9finition : On dit qu'un sous-programme (proc\u00e9dure ou fonction) est r\u00e9cursif s'il s'appelle lui-m\u00eame Il est indispensable de pr\u00e9voir une condition d'arr\u00eat \u00e0 la r\u00e9cursion sinon la fonction va s'appeler une infinit\u00e9 de fois. Dans la pratique, la pile qui stocke les appels r\u00e9cursifs est de taille finie. Une fois qu'elle est pleine, le programme ne r\u00e9pondra plus Exercice : Donner une d\u00e9finition r\u00e9cursive qui correspond au calcul de la fonction factorielle \\(n!\\) d\u00e9finie par \\(n!=1\\times 2 \\times 3 \\times ...\\times n\\) si \\(n>0\\) et \\(0!=1\\) . \u00c9crire \u00e9galement le code d'une fonction fact(n) qui impl\u00e9mente cette d\u00e9finition. Pour les plus rapides, \u00e9crire la version it\u00e9rative.} Exercice : \u00c9crire une fonction r\u00e9cursive boucle(i,k) qui affiche les entiers entre i et k . Par exemple, boucle(0,3) affiche 0,1,2,3. Pour les plus rapides, \u00e9crire la version it\u00e9rative. Exercice : La m\u00e9thode du paysan russe est un tr\u00e8s vieil algorithme de multiplication de deux nombres entiers d\u00e9j\u00e0 d\u00e9crit, sous forme l\u00e9g\u00e8rement diff\u00e9rente, sur un papyrus \u00e9gyptien r\u00e9dig\u00e9 autour de 1650 avant J.-C. Il s'agissait de la principale m\u00e9thode de calcul en Europe avant l'introduction des chiffres arabes. Les ordinateurs l'ont utilis\u00e9 avant que la multiplication ne soit directement int\u00e9gr\u00e9 dans le processeur sous forme de circuit \u00e9lectronique. Sous une forme moderne, il peut \u00eatre d\u00e9crit par le programme 1. Appliquer cette fonction pour effectuer la multiplication de 105 par 253. D\u00e9tailler les \u00e9tapes dans le tableau suivant : |x | y | p | |---\u2013|----|------| |105 |253 | .... | |... |....|..... | On admet que cet algorithme repose sur les relations suivantes : \\( \\( x*y= \\left \\{ \\begin{array}{l l l} 0 & si &x=0 \\\\ (x//2)*(y+y) & si & x\\ est\\ pair\\\\ (x//2)*(y+y)+y & si & x\\ est\\ impair\\\\ \\end{array} \\right . \\) \\) Proposer une version r\u00e9cursive de cet algorithme. 1 2 3 4 5 6 7 8 Fonction multiplication ( x , y ): p = 0 TANT QUE x > 0 : Si x est impair : p = p + y x = x // 2 y = y + y Retourner p Fonctionnement d'une fonction r\u00e9cursive # Par exemple, l'\u00e9valuation de l'appel \u00e0 somme(3) du programme somme_rec peut se repr\u00e9senter de la mani\u00e8re suivante : o\u00f9 on indique uniquement pour chaque appel \u00e0 somme(n) l'instruction qui est ex\u00e9cut\u00e9e apr\u00e8s le test n==0 de la conditionnelle. Cette mani\u00e8re de repr\u00e9senter l'ex\u00e9cution d'un programme en indiquant les diff\u00e9rents appels effectu\u00e9s est appel\u00e9e un arbre d'appels Ainsi, pour calculer la valeur renvoy\u00e9e par somme(3) , il faut tout d'abord appeler somme(2) . Cet appel va lui-m\u00eame d\u00e9clencher un appel \u00e0 somme(1) , qui \u00e0 son tour n\u00e9cessite un appel \u00e0 somme(0) . Ce dernier appel se termine en renvoyant la valeur 0. Le calcul de somme(3) se fait donc \"\u00e0 rebours\". Une fois que l'appel \u00e0 somme(0) }` est termin\u00e9, c'est-\u00e0-dire que la valeur 0 a \u00e9t\u00e9 renvoy\u00e9e, l'arbre d'appels a la forme suivante. A cet instant, l'appel \u00e0 somme(1) }` peut alors se terminer et renvoyer le r\u00e9sultat de la somme 1+0. L'arbre d'appels est alors le suivant : Enfin, l'appel \u00e0 somme(2) peut lui-m\u00eame renvoyer la valeur 2+1 comme r\u00e9sultat, ce qui permet \u00e0 somme(3) de se terminer en renvoyant le r\u00e9sultat 3+3. On obtient bien au final la valeur 6 attendue. R\u00e9cursivit\u00e9 ou it\u00e9rativit\u00e9 ? # Lorsque l'on programme des fonctions qui ne s'appellent pas, on dit que l'on programme de mani\u00e8re it\u00e9rative. Il est toujours possible de transformer une fonction it\u00e9rative en fonction r\u00e9cursive et vice et versa. La m\u00e9thode it\u00e9rative nous est plus famili\u00e8re et est plus rapide une fois le code impl\u00e9ment\u00e9 dans un langage de programmation. La m\u00e9thode r\u00e9cursive est plus \u00e9l\u00e9gante et lisible et \u00e9vite d'utiliser de nombreuses structures it\u00e9ratives. Elle est \u00e9galement tr\u00e8s utile pour concevoir des structures de donn\u00e9es complexes comme les listes, les arbres et les graphes. L'inconv\u00e9nient le plus important de cette m\u00e9thode, est qu'une fois impl\u00e9ment\u00e9e dans un langage de programmation, elle est tr\u00e8s gourmande en ressource m\u00e9moire. Du fait que l'on empile, tous les appels r\u00e9cursifs, des d\u00e9bordements de capacit\u00e9 peuvent se produire lorsque la pile est pleine. R\u00e9cursivit\u00e9 crois\u00e9e # Dans cette m\u00e9thode r\u00e9cursive, il arrive qu'une fonction appelle une autre fonction qui appelle elle-m\u00eame la premi\u00e8re, ce cas est appel\u00e9e r\u00e9cursivit\u00e9 crois\u00e9e. Prenons, par exemple deux fonctions ci-dessous permettant de tester si un nombre est pair ou impair comme dans le programme pair_impair.py . paire_impaire.py 1 2 3 4 5 6 7 8 9 10 11 def Pair ( n ): if n == 0 : return True else : return Impair ( n - 1 ) def Impair ( n ): if n == 0 : return False else : return Pair ( n - 1 ) Ce n'est \u00e9videmment pas la m\u00e9thode la plus simple mais elle fonctionne. On aurait pu par exemple tester le reste de la division euclidienne de n par deux. R\u00e9cursivit\u00e9 multiple # Il existe un autre cas particulier o\u00f9 la fonction s'appelle plusieurs fois. On parle alors de r\u00e9cursivit\u00e9 multiple. C'est le cas par exemple dans le cas du calcul des coefficients binomiaux. On peut donner une rappel math\u00e9matique de ces coefficients binomiaux qui sont caract\u00e9ris\u00e9s par la d\u00e9finition suivante pour toute valeur enti\u00e8re de \\(n\\) et \\(k\\) telles que \\(0\\leq k\\leq n \\) : \\[\\begin{pmatrix} n \\\\ k \\end{pmatrix}= \\left \\{ \\begin{array}{l l l} 1 & si &k=0 \\\\ 1 & si & k=n\\\\ \\begin{pmatrix} n-1 \\\\ k-1 \\end{pmatrix}+\\begin{pmatrix} n-1 \\\\ k \\end{pmatrix}& sinon \\end{array} \\right . \\] Alors on peut donner la fonction algorithmique de ce programme. bino.py 1 2 3 4 5 Fonction CoeffBinomial ( n , k ): Si k == 0 OU k == n : Retourner 1 Sinon : Retourner CoeffBinomial ( n - 1 , k - 1 ) + CoeffBinomial ( n - 1 , k ) Exercices # Exercice : En math\u00e9matiques, la suite de Fibonacci est une suite d'entiers dans laquelle chaque terme est la somme des deux termes qui le pr\u00e9c\u00e8dent. Not\u00e9e \\(F_{n}\\) , elle est d\u00e9finie par \\({\\displaystyle F_{0}=0,\\quad F_{1}=1}\\) , et \\({\\displaystyle F_{n}=F_{n-1}+F_{n-2}}\\) pour \\({\\displaystyle n\\geqslant 2}\\) . Les termes de cette suite sont appel\u00e9s nombres de Fibonacci et forment la suite A000045 de l'OEIS : F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F1 F12 F13 F14 F15 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 Repr\u00e9sentation g\u00e9om\u00e9trique de la fraction continue de \u03c6 faisant appara\u00eetre les nombres de la suite de Fibonacci. Cette suite est li\u00e9e au nombre d'or, \u03c6 (phi) : ce nombre intervient dans l'expression du terme g\u00e9n\u00e9ral de la suite. Inversement, la suite de Fibonacci intervient dans l'\u00e9criture des r\u00e9duites de l'expression de \u03c6 en fraction continue : les quotients de deux termes cons\u00e9cutifs de la suite de Fibonacci sont les meilleures approximations du nombre d'or. Le but de cet exercice est de r\u00e9aliser une fonction qui calcule la valeur de de la suite de Fibonacci pour un rang n. L'objectif de cet exercice est de r\u00e9aliser la fractale de Von Koch \u00e0 l'aide du module python \\textit{turtle}. \\textbf{Il faudra lire attentivement la documentation}. Vous ferez cet exercice dans le cadre du Projet 2. Exercice : Une fractale est une sorte de courbe math\u00e9matique un peu complexe riche en d\u00e9tail, et qui poss\u00e8de une propri\u00e9t\u00e9 int\u00e9ressante visuellement : lorsque l'on regarde des d\u00e9tails de petite taille, on retrouve des formes correspondant aux d\u00e9tails de plus grande taille (auto-similarit\u00e9). Cela nous rappelle \u00e9trangement la r\u00e9cursivit\u00e9 ! La premi\u00e8re courbe \u00e0 tracer a \u00e9t\u00e9 imagin\u00e9e en 1904 par le math\u00e9maticien su\u00e9dois Niels Fabian Helge Von Koch. Le principe est simple : on divise un segment initial en trois morceaux, et on construit un triangle \u00e9quilat\u00e9ral sans base au-dessus du morceau central. On r\u00e9it\u00e8re le processus \\(n\\) fois, \\(n\\) est appel\u00e9 l'ordre. Dans la figure suivante, on voit les ordres 0,1,2 et 3 de cette fractale. Proposer une fonction r\u00e9cursive permettant de dessiner la fractale de Von Koch en lui donnant comme param\u00e8tre l'ordre et la longueur du segment initial. Le flocon de Koch s'obtient de la m\u00eame fa\u00e7on que la fractale pr\u00e9c\u00e9dente, en partant d'un triangle \u00e9quilat\u00e9ral au lieu d'un segment de droite, et en effectuant les modifications en orientant les triangles vers l'ext\u00e9rieur. Proposer une fonction permettant de faire le flocon de Koch complet \u00e0 partir de la fonction r\u00e9alis\u00e9e pr\u00e9c\u00e9dente.","title":"Cours"},{"location":"Terminale/R%C3%A9cursivit%C3%A9/recursivite/#recursivite","text":"","title":"R\u00e9cursivit\u00e9"},{"location":"Terminale/R%C3%A9cursivit%C3%A9/recursivite/#contexte-la-somme-des-premiers-entiers","text":"Pour d\u00e9finir la somme des \\(n\\) premiers entiers, on a l'habitude de d'\u00e9crire la formule suivante : \\[ 0 + 1 + 2 + 3 + .... + n \\] Cette formulation peut nous appara\u00eetre simple et intuitive. Exercice : \u00c9crire une fonction somme(n) qui retourne la somme des \\(n\\) premiers entiers. Or ce code n'est pas directement li\u00e9 \u00e0 la formule pr\u00e9c\u00e9dente. En effet, il n'y a rien dans cette formule qui laisse penser qu'il faille une variable interm\u00e9diaire pour calculer cette somme. C'est pourquoi, nous allons tenter de d\u00e9finir autrement cette fonction : \\[ somme(n)= \\left \\{ \\begin{array}{l l l} 0 & si &n=0 \\\\ n+somme(n-1) & si & n>0 \\end{array} \\right . \\] Cette d\u00e9finition nous indique ce que vaut somme ( n ) pour un entier \\(n\\) quelconque, selon que \\(n\\) soit \u00e9gal \u00e0 0 ou strictement positif. Ainsi, pour, pour le cas o\u00f9 \\(n\\) =0, la valeur de somme(n) vaut 0, et dans le cas o\u00f9 \\(n\\) est strictement positif, la valeur de somme(n) est \\(n+somme(n-1)\\) . Par exemple, voici ci-dessous les valeurs de 'somme(n)', pour \\(n\\) valant 0,1,2 et 3. \\[ \\begin{array}{l } somme(0)=0 \\\\ somme(1)=1+somme(0)=1+0=1 \\\\ somme(2)=2+somme(1)=2+1=3 \\end{array} \\] L'int\u00e9r\u00eat de cette formulation est qu'elle est directement programmable. En python, cela donne le programme ci-dessous. somme_rec.py 1 2 3 4 5 def somme ( n : int ) -> int : if n == 0 : return 0 else : return n + somme ( n - 1 )","title":"Contexte : la somme des premiers entiers"},{"location":"Terminale/R%C3%A9cursivit%C3%A9/recursivite/#recursivite_1","text":"D\u00e9finition : On dit qu'un sous-programme (proc\u00e9dure ou fonction) est r\u00e9cursif s'il s'appelle lui-m\u00eame Il est indispensable de pr\u00e9voir une condition d'arr\u00eat \u00e0 la r\u00e9cursion sinon la fonction va s'appeler une infinit\u00e9 de fois. Dans la pratique, la pile qui stocke les appels r\u00e9cursifs est de taille finie. Une fois qu'elle est pleine, le programme ne r\u00e9pondra plus Exercice : Donner une d\u00e9finition r\u00e9cursive qui correspond au calcul de la fonction factorielle \\(n!\\) d\u00e9finie par \\(n!=1\\times 2 \\times 3 \\times ...\\times n\\) si \\(n>0\\) et \\(0!=1\\) . \u00c9crire \u00e9galement le code d'une fonction fact(n) qui impl\u00e9mente cette d\u00e9finition. Pour les plus rapides, \u00e9crire la version it\u00e9rative.} Exercice : \u00c9crire une fonction r\u00e9cursive boucle(i,k) qui affiche les entiers entre i et k . Par exemple, boucle(0,3) affiche 0,1,2,3. Pour les plus rapides, \u00e9crire la version it\u00e9rative. Exercice : La m\u00e9thode du paysan russe est un tr\u00e8s vieil algorithme de multiplication de deux nombres entiers d\u00e9j\u00e0 d\u00e9crit, sous forme l\u00e9g\u00e8rement diff\u00e9rente, sur un papyrus \u00e9gyptien r\u00e9dig\u00e9 autour de 1650 avant J.-C. Il s'agissait de la principale m\u00e9thode de calcul en Europe avant l'introduction des chiffres arabes. Les ordinateurs l'ont utilis\u00e9 avant que la multiplication ne soit directement int\u00e9gr\u00e9 dans le processeur sous forme de circuit \u00e9lectronique. Sous une forme moderne, il peut \u00eatre d\u00e9crit par le programme 1. Appliquer cette fonction pour effectuer la multiplication de 105 par 253. D\u00e9tailler les \u00e9tapes dans le tableau suivant : |x | y | p | |---\u2013|----|------| |105 |253 | .... | |... |....|..... | On admet que cet algorithme repose sur les relations suivantes : \\( \\( x*y= \\left \\{ \\begin{array}{l l l} 0 & si &x=0 \\\\ (x//2)*(y+y) & si & x\\ est\\ pair\\\\ (x//2)*(y+y)+y & si & x\\ est\\ impair\\\\ \\end{array} \\right . \\) \\) Proposer une version r\u00e9cursive de cet algorithme. 1 2 3 4 5 6 7 8 Fonction multiplication ( x , y ): p = 0 TANT QUE x > 0 : Si x est impair : p = p + y x = x // 2 y = y + y Retourner p","title":"R\u00e9cursivit\u00e9"},{"location":"Terminale/R%C3%A9cursivit%C3%A9/recursivite/#fonctionnement-dune-fonction-recursive","text":"Par exemple, l'\u00e9valuation de l'appel \u00e0 somme(3) du programme somme_rec peut se repr\u00e9senter de la mani\u00e8re suivante : o\u00f9 on indique uniquement pour chaque appel \u00e0 somme(n) l'instruction qui est ex\u00e9cut\u00e9e apr\u00e8s le test n==0 de la conditionnelle. Cette mani\u00e8re de repr\u00e9senter l'ex\u00e9cution d'un programme en indiquant les diff\u00e9rents appels effectu\u00e9s est appel\u00e9e un arbre d'appels Ainsi, pour calculer la valeur renvoy\u00e9e par somme(3) , il faut tout d'abord appeler somme(2) . Cet appel va lui-m\u00eame d\u00e9clencher un appel \u00e0 somme(1) , qui \u00e0 son tour n\u00e9cessite un appel \u00e0 somme(0) . Ce dernier appel se termine en renvoyant la valeur 0. Le calcul de somme(3) se fait donc \"\u00e0 rebours\". Une fois que l'appel \u00e0 somme(0) }` est termin\u00e9, c'est-\u00e0-dire que la valeur 0 a \u00e9t\u00e9 renvoy\u00e9e, l'arbre d'appels a la forme suivante. A cet instant, l'appel \u00e0 somme(1) }` peut alors se terminer et renvoyer le r\u00e9sultat de la somme 1+0. L'arbre d'appels est alors le suivant : Enfin, l'appel \u00e0 somme(2) peut lui-m\u00eame renvoyer la valeur 2+1 comme r\u00e9sultat, ce qui permet \u00e0 somme(3) de se terminer en renvoyant le r\u00e9sultat 3+3. On obtient bien au final la valeur 6 attendue.","title":"Fonctionnement d'une fonction r\u00e9cursive"},{"location":"Terminale/R%C3%A9cursivit%C3%A9/recursivite/#recursivite-ou-iterativite","text":"Lorsque l'on programme des fonctions qui ne s'appellent pas, on dit que l'on programme de mani\u00e8re it\u00e9rative. Il est toujours possible de transformer une fonction it\u00e9rative en fonction r\u00e9cursive et vice et versa. La m\u00e9thode it\u00e9rative nous est plus famili\u00e8re et est plus rapide une fois le code impl\u00e9ment\u00e9 dans un langage de programmation. La m\u00e9thode r\u00e9cursive est plus \u00e9l\u00e9gante et lisible et \u00e9vite d'utiliser de nombreuses structures it\u00e9ratives. Elle est \u00e9galement tr\u00e8s utile pour concevoir des structures de donn\u00e9es complexes comme les listes, les arbres et les graphes. L'inconv\u00e9nient le plus important de cette m\u00e9thode, est qu'une fois impl\u00e9ment\u00e9e dans un langage de programmation, elle est tr\u00e8s gourmande en ressource m\u00e9moire. Du fait que l'on empile, tous les appels r\u00e9cursifs, des d\u00e9bordements de capacit\u00e9 peuvent se produire lorsque la pile est pleine.","title":"R\u00e9cursivit\u00e9 ou it\u00e9rativit\u00e9 ?"},{"location":"Terminale/R%C3%A9cursivit%C3%A9/recursivite/#recursivite-croisee","text":"Dans cette m\u00e9thode r\u00e9cursive, il arrive qu'une fonction appelle une autre fonction qui appelle elle-m\u00eame la premi\u00e8re, ce cas est appel\u00e9e r\u00e9cursivit\u00e9 crois\u00e9e. Prenons, par exemple deux fonctions ci-dessous permettant de tester si un nombre est pair ou impair comme dans le programme pair_impair.py . paire_impaire.py 1 2 3 4 5 6 7 8 9 10 11 def Pair ( n ): if n == 0 : return True else : return Impair ( n - 1 ) def Impair ( n ): if n == 0 : return False else : return Pair ( n - 1 ) Ce n'est \u00e9videmment pas la m\u00e9thode la plus simple mais elle fonctionne. On aurait pu par exemple tester le reste de la division euclidienne de n par deux.","title":"R\u00e9cursivit\u00e9 crois\u00e9e"},{"location":"Terminale/R%C3%A9cursivit%C3%A9/recursivite/#recursivite-multiple","text":"Il existe un autre cas particulier o\u00f9 la fonction s'appelle plusieurs fois. On parle alors de r\u00e9cursivit\u00e9 multiple. C'est le cas par exemple dans le cas du calcul des coefficients binomiaux. On peut donner une rappel math\u00e9matique de ces coefficients binomiaux qui sont caract\u00e9ris\u00e9s par la d\u00e9finition suivante pour toute valeur enti\u00e8re de \\(n\\) et \\(k\\) telles que \\(0\\leq k\\leq n \\) : \\[\\begin{pmatrix} n \\\\ k \\end{pmatrix}= \\left \\{ \\begin{array}{l l l} 1 & si &k=0 \\\\ 1 & si & k=n\\\\ \\begin{pmatrix} n-1 \\\\ k-1 \\end{pmatrix}+\\begin{pmatrix} n-1 \\\\ k \\end{pmatrix}& sinon \\end{array} \\right . \\] Alors on peut donner la fonction algorithmique de ce programme. bino.py 1 2 3 4 5 Fonction CoeffBinomial ( n , k ): Si k == 0 OU k == n : Retourner 1 Sinon : Retourner CoeffBinomial ( n - 1 , k - 1 ) + CoeffBinomial ( n - 1 , k )","title":"R\u00e9cursivit\u00e9 multiple"},{"location":"Terminale/R%C3%A9cursivit%C3%A9/recursivite/#exercices","text":"Exercice : En math\u00e9matiques, la suite de Fibonacci est une suite d'entiers dans laquelle chaque terme est la somme des deux termes qui le pr\u00e9c\u00e8dent. Not\u00e9e \\(F_{n}\\) , elle est d\u00e9finie par \\({\\displaystyle F_{0}=0,\\quad F_{1}=1}\\) , et \\({\\displaystyle F_{n}=F_{n-1}+F_{n-2}}\\) pour \\({\\displaystyle n\\geqslant 2}\\) . Les termes de cette suite sont appel\u00e9s nombres de Fibonacci et forment la suite A000045 de l'OEIS : F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F1 F12 F13 F14 F15 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 Repr\u00e9sentation g\u00e9om\u00e9trique de la fraction continue de \u03c6 faisant appara\u00eetre les nombres de la suite de Fibonacci. Cette suite est li\u00e9e au nombre d'or, \u03c6 (phi) : ce nombre intervient dans l'expression du terme g\u00e9n\u00e9ral de la suite. Inversement, la suite de Fibonacci intervient dans l'\u00e9criture des r\u00e9duites de l'expression de \u03c6 en fraction continue : les quotients de deux termes cons\u00e9cutifs de la suite de Fibonacci sont les meilleures approximations du nombre d'or. Le but de cet exercice est de r\u00e9aliser une fonction qui calcule la valeur de de la suite de Fibonacci pour un rang n. L'objectif de cet exercice est de r\u00e9aliser la fractale de Von Koch \u00e0 l'aide du module python \\textit{turtle}. \\textbf{Il faudra lire attentivement la documentation}. Vous ferez cet exercice dans le cadre du Projet 2. Exercice : Une fractale est une sorte de courbe math\u00e9matique un peu complexe riche en d\u00e9tail, et qui poss\u00e8de une propri\u00e9t\u00e9 int\u00e9ressante visuellement : lorsque l'on regarde des d\u00e9tails de petite taille, on retrouve des formes correspondant aux d\u00e9tails de plus grande taille (auto-similarit\u00e9). Cela nous rappelle \u00e9trangement la r\u00e9cursivit\u00e9 ! La premi\u00e8re courbe \u00e0 tracer a \u00e9t\u00e9 imagin\u00e9e en 1904 par le math\u00e9maticien su\u00e9dois Niels Fabian Helge Von Koch. Le principe est simple : on divise un segment initial en trois morceaux, et on construit un triangle \u00e9quilat\u00e9ral sans base au-dessus du morceau central. On r\u00e9it\u00e8re le processus \\(n\\) fois, \\(n\\) est appel\u00e9 l'ordre. Dans la figure suivante, on voit les ordres 0,1,2 et 3 de cette fractale. Proposer une fonction r\u00e9cursive permettant de dessiner la fractale de Von Koch en lui donnant comme param\u00e8tre l'ordre et la longueur du segment initial. Le flocon de Koch s'obtient de la m\u00eame fa\u00e7on que la fractale pr\u00e9c\u00e9dente, en partant d'un triangle \u00e9quilat\u00e9ral au lieu d'un segment de droite, et en effectuant les modifications en orientant les triangles vers l'ext\u00e9rieur. Proposer une fonction permettant de faire le flocon de Koch complet \u00e0 partir de la fonction r\u00e9alis\u00e9e pr\u00e9c\u00e9dente.","title":"Exercices"}]}